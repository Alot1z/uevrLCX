# ðŸ”§ UEVR Core Files Analysis
## Komplet analyse af alle core filer

**Genereret:** 2025-08-19 12:20:09  
**Antal filer:** 11  
**Status:** âœ… Komplet

---

## ðŸ“ Framework.cpp
**Sti:** $filePath  
**StÃ¸rrelse:** 69705 bytes  
**Sidst Ã¦ndret:** 2025-08-19 03:26:32

### ðŸ”— Includes
`cpp
#include <chrono>
`

### ðŸ—ï¸ Classes
`cpp

`

### âš™ï¸ Functions
`cpp
void Framework::hook_monitor()
`

### ðŸ“„ Komplet Indhold
`cpp
#include <chrono>
#include <filesystem>

#include <windows.h>
#include <ShlObj.h>

#include <spdlog/sinks/basic_file_sink.h>

#include <imgui.h>
#include "uevr-imgui/font_robotomedium.hpp"
#include "uevr-imgui/imgui_impl_dx11.h"
#include "uevr-imgui/imgui_impl_dx12.h"
#include "uevr-imgui/imgui_impl_win32.h"

#include "utility/Module.hpp"
#include "utility/Patch.hpp"
#include "utility/Scan.hpp"
#include "utility/Thread.hpp"
#include "utility/String.hpp"
#include "utility/Input.hpp"

#include "WindowFilter.hpp"

#include "Mods.hpp"
#include "mods/PluginLoader.hpp"
#include "mods/VR.hpp"
#include "mods/ImGuiThemeHelpers.hpp"

#include "CommitHash.autogenerated"
#include "ExceptionHandler.hpp"
#include "LicenseStrings.hpp"
#include "mods/FrameworkConfig.hpp"
#include "Framework.hpp"

namespace fs = std::filesystem;
using namespace std::literals;

std::unique_ptr<Framework> g_framework{};

uevrSharedMemory::uevrSharedMemory() {
    spdlog::info("Shared memory constructor!");

    m_memory = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(Data), "UnrealVRMod");
    m_data = (Data*)MapViewOfFile(m_memory, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(Data));

    if (m_data != nullptr) {
        const auto p = *utility::get_module_pathw(utility::get_executable());
        std::memset(m_data->path, 0, sizeof(m_data->path));
        std::wcsncpy(m_data->path, p.c_str(), p.length());
        m_data->path[p.length()] = L'\0';
        m_data->pid = GetCurrentProcessId();
        spdlog::info("Mapped memory!");
    } else {
        spdlog::error("Failed to map memory!");
    }
}

void Framework::hook_monitor() {
    if (!m_hook_monitor_mutex.try_lock()) {
        // If this happens then we can assume execution is going as planned
        // so we can just reset the times so we dont break something
        m_last_present_time = std::chrono::steady_clock::now() + std::chrono::seconds(5);
        m_last_chance_time = std::chrono::steady_clock::now() + std::chrono::seconds(1);
        m_has_last_chance = true;
    } else {
        m_hook_monitor_mutex.unlock();
    }

    std::scoped_lock _{ m_hook_monitor_mutex };

    if (g_framework == nullptr) {
        return;
    }

    if (g_framework->m_wnd != nullptr) {
        // Check if window is minimzed and just return if it is
        // Because some games don't continuously call present when minimized
        if (IsWindow(g_framework->m_wnd) && IsIconic(g_framework->m_wnd)) {
            //spdlog::info("Window is minimized, skipping hook monitor");
            m_last_present_time = std::chrono::steady_clock::now() + std::chrono::seconds(5);
            m_last_chance_time = std::chrono::steady_clock::now() + std::chrono::seconds(1);
            m_has_last_chance = true;
            return;
        }
    }

    const auto now = std::chrono::steady_clock::now();

    auto& d3d11 = get_d3d11_hook();
    auto& d3d12 = get_d3d12_hook();

    const auto renderer_type = get_renderer_type();

    if (d3d11 == nullptr || d3d12 == nullptr 
        || (renderer_type == Framework::RendererType::D3D11 && d3d11 != nullptr && !d3d11->is_inside_present()) 
        || (renderer_type == Framework::RendererType::D3D12 && d3d12 != nullptr && !d3d12->is_inside_present())) 
    {
        // check if present time is more than 5 seconds ago
        if (now - m_last_present_time >= std::chrono::seconds(5)) {
            if (m_has_last_chance) {
                // the purpose of this is to make sure that the game is not frozen
                // e.g. if we are debugging the game, so we don't rehook anything on accident
                m_has_last_chance = false;
                m_last_chance_time = now;

                spdlog::info("Last chance encountered for hooking");
            }

            if (!m_has_last_chance && now - m_last_chance_time > std::chrono::seconds(1)) {
                spdlog::info("Sending rehook request for D3D");

                // hook_d3d12 always gets called first.
                if (m_is_d3d11) {
                    hook_d3d11();
                } else {
                    hook_d3d12();
                }

                // so we don't immediately go and hook it again
                // add some additional time to it to give it some leeway
                m_last_present_time = std::chrono::steady_clock::now() + std::chrono::seconds(5);
                m_last_message_time = std::chrono::steady_clock::now() + std::chrono::seconds(5);
                m_last_chance_time = std::chrono::steady_clock::now() + std::chrono::seconds(1);
                m_has_last_chance = true;
            }
        } else {
            m_last_chance_time = std::chrono::steady_clock::now();
            m_has_last_chance = true;
        }

        if (m_initialized && m_wnd != 0 && now - m_last_message_time > std::chrono::seconds(5)) {
            if (m_windows_message_hook != nullptr && m_windows_message_hook->is_hook_intact()) {
                spdlog::info("Windows message hook is still intact, ignoring...");
                m_last_message_time = now;
                m_last_sendmessage_time = now;
                m_sent_message = false;
                return;
            }

            // send dummy message to window to check if our hook is still intact
            if (!m_sent_message) {
                spdlog::info("Sending initial message hook test");

                auto proc = (WNDPROC)GetWindowLongPtr(m_wnd, GWLP_WNDPROC);

                if (proc != nullptr) {
                    const auto ret = CallWindowProc(proc, m_wnd, WM_NULL, 0, 0);

                    spdlog::info("Hook test message sent");
                }

                m_last_sendmessage_time = std::chrono::steady_clock::now();
                m_sent_message = true;
            } else if (now - m_last_sendmessage_time > std::chrono::seconds(1)) {
                spdlog::info("Sending reinitialization request for message hook");

                // if we don't get a message for 5 seconds, assume the hook is broken
                //m_initialized = false; // causes the hook to be re-initialized next frame
                m_message_hook_requested = true;
                m_last_message_time = std::chrono::steady_clock::now() + std::chrono::seconds(5);
                m_last_present_time = std::chrono::steady_clock::now() + std::chrono::seconds(5);

                m_sent_message = false;
            }
        } else {
            m_sent_message = false;
        }
    }
}

void Framework::command_thread() {
    m_uevr_shared_memory->data().command_thread_id = GetCurrentThreadId();

    MSG msg{};
    if (PeekMessageA(&msg, (HWND)-1, WM_USER, WM_USER, PM_REMOVE) == 0) {
        return;
    }

    if (msg.message != WM_USER) {
        return;
    }

    if (msg.wParam == uevrSharedMemory::MESSAGE_IDENTIFIER) {
        on_frontend_command((uevrSharedMemory::Command)msg.lParam);
    }
}

Framework::Framework(HMODULE framework_module)
    : m_framework_module{framework_module}
    , m_game_module{GetModuleHandle(0)},
    m_logger{spdlog::basic_logger_mt("UnrealVR", (get_persistent_dir() / "log.txt").string(), true)} 
{
    std::scoped_lock __{m_constructor_mutex};

    spdlog::set_default_logger(m_logger);
    spdlog::flush_on(spdlog::level::info);
    spdlog::info("UnrealVR entry");
    spdlog::info("Commit hash: {}", uevr_COMMIT_HASH);
    spdlog::info("Tag: {}", uevr_TAG);
    spdlog::info("Commits past tag: {}", uevr_COMMITS_PAST_TAG);
    spdlog::info("Branch: {}", uevr_BRANCH);
    spdlog::info("Total commits: {}", uevr_TOTAL_COMMITS);
    spdlog::info("Build date: {}", uevr_BUILD_DATE);
    spdlog::info("Build time: {}", uevr_BUILD_TIME);

    const auto module_size = *utility::get_module_size(m_game_module);

    spdlog::info("Game Module Addr: {:x}", (uintptr_t)m_game_module);
    spdlog::info("Game Module Size: {:x}", module_size);

    IMGUI_CHECKVERSION();
    ImGui::CreateContext();

#ifdef DEBUG
    spdlog::set_level(spdlog::level::debug);
#endif

    // Create the typedef for RtlGetVersion
    typedef LONG (*RtlGetVersionFunc)(PRTL_OSVERSIONINFOW);

    const auto ntdll = GetModuleHandle("ntdll.dll");

    if (ntdll != nullptr) {
        // Manually get RtlGetVersion
        auto rtl_get_version = (RtlGetVersionFunc)GetProcAddress(ntdll, "RtlGetVersion");

        if (rtl_get_version != nullptr) {
            spdlog::info("Getting OS version information...");

            // Create an initial log that prints out the user's Windows OS version information
            // With the major and minor version numbers
            // Using RtlGetVersion()
            OSVERSIONINFOW os_version_info{};
            ZeroMemory(&os_version_info, sizeof(OSVERSIONINFOW));
            os_version_info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
            os_version_info.dwMajorVersion = 0;
            os_version_info.dwMinorVersion = 0;
            os_version_info.dwBuildNumber = 0;
            os_version_info.dwPlatformId = 0;

            if (rtl_get_version(&os_version_info) != 0) {
                spdlog::info("RtlGetVersion() failed");
            } else {
                // Log the Windows version information
                spdlog::info("OS Version Information");
                spdlog::info("\tMajor Version: {}", os_version_info.dwMajorVersion);
                spdlog::info("\tMinor Version: {}", os_version_info.dwMinorVersion);
                spdlog::info("\tBuild Number: {}", os_version_info.dwBuildNumber);
                spdlog::info("\tPlatform Id: {}", os_version_info.dwPlatformId);

                spdlog::info("Disclaimer: Framework does not send this information to the developers or any other third party.");
                spdlog::info("This information is only used to help with the development of Framework.");
            }
        } else {
            spdlog::info("RtlGetVersion() not found");
        }
    } else {
        spdlog::info("ntdll.dll not found");
    }

    // Hooking D3D12 initially because we need to retrieve the command queue before the first frame then switch to D3D11 if it failed later
    // on
    // addendum: now we don't need to do that, we just grab the command queue offset from the swapchain we create
    /*if (!hook_d3d12()) {
        spdlog::error("Failed to hook D3D12 for initial test.");
    }*/

    std::scoped_lock _{m_hook_monitor_mutex};
    PluginLoader::get()->early_init();

    m_last_present_time = std::chrono::steady_clock::time_point{}; // Instantly send the first message
    m_last_message_time = std::chrono::steady_clock::time_point{}; // Instantly send the first message
    m_last_chance_time = std::chrono::steady_clock::time_point{}; // Instantly send the first message
    m_has_last_chance = false;

    m_uevr_shared_memory = std::make_unique<uevrSharedMemory>();
    m_command_thread = std::make_unique<std::jthread>([this](std::stop_token s) {
        spdlog::info("Command thread entry");

        {
            std::scoped_lock _{m_constructor_mutex};

            while (g_framework == nullptr) {
                std::this_thread::yield();
            }
        }

        while (!s.stop_requested() && !m_terminating) {
            this->command_thread();
            std::this_thread::sleep_for(std::chrono::milliseconds(33));
        }
    });

    m_d3d_monitor_thread = std::make_unique<std::jthread>([this](std::stop_token s) {
        spdlog::info("D3D monitor thread entry");

        {
            std::scoped_lock _{m_constructor_mutex};

            while (g_framework == nullptr) {
                std::this_thread::yield();
            }
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(33));

        while (!s.stop_requested() && !m_terminating) {
            this->hook_monitor();
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
        }
    });

    spdlog::info("Leaving Framework constructor");
}

bool Framework::hook_d3d11() {
    //if (m_d3d11_hook == nullptr) {
        m_d3d11_hook.reset();
        m_d3d11_hook = std::make_unique<D3D11Hook>();
        m_d3d11_hook->on_present([this](D3D11Hook& hook) { on_frame_d3d11(); });
        m_d3d11_hook->on_post_present([this](D3D11Hook& hook) { on_post_present_d3d11(); });
        m_d3d11_hook->on_resize_buffers([this](D3D11Hook& hook, uint32_t w, uint32_t h) { on_reset(w, h); });
    //}

    // Making sure D3D12 is not hooked
    if (!m_is_d3d12) {
        if (m_d3d11_hook->hook()) {
            spdlog::info("Hooked DirectX 11");
            m_valid = true;
            m_is_d3d11 = true;
            return true;
        }
        // We make sure to no unhook any unwanted hooks if D3D11 didn't get hooked properly
        if (m_d3d11_hook->unhook()) {
            spdlog::info("D3D11 unhooked!");
        } else {
            spdlog::info("Cannot unhook D3D11, this might crash.");
        }

        m_valid = false;
        m_is_d3d11 = false;
        return false;
    }

    return false;
}

bool Framework::hook_d3d12() {
    // windows 7?
    if (LoadLibraryA("d3d12.dll") == nullptr) {
        spdlog::info("d3d12.dll not found, user is probably running Windows 7.");
        spdlog::info("Falling back to hooking D3D11.");

        m_is_d3d12 = false;
        return hook_d3d11();
    }

    //if (m_d3d12_hook == nullptr) {
        m_d3d12_hook.reset();
        m_d3d12_hook = std::make_unique<D3D12Hook>();
        m_d3d12_hook->on_present([this](D3D12Hook& hook) { on_frame_d3d12(); });
        m_d3d12_hook->on_post_present([this](D3D12Hook& hook) { on_post_present_d3d12(); });
        m_d3d12_hook->on_resize_buffers([this](D3D12Hook& hook, uint32_t w, uint32_t h) { on_reset(w, h); });
        m_d3d12_hook->on_resize_target([this](D3D12Hook& hook, uint32_t w, uint32_t h) { on_reset(w, h); });
    //}
    //m_d3d12_hook->on_create_swap_chain([this](D3D12Hook& hook) { m_d3d12.command_queue = m_d3d12_hook->get_command_queue(); });

    // Making sure D3D11 is not hooked
    if (!m_is_d3d11) {
        if (m_d3d12_hook->hook()) {
            spdlog::info("Hooked DirectX 12");
            m_valid = true;
            m_is_d3d12 = true;
            return true;
        }
        // We make sure to no unhook any unwanted hooks if D3D12 didn't get hooked properly
        if (m_d3d12_hook->unhook()) {
            spdlog::info("D3D12 Unhooked!");
        } else {
            spdlog::info("Cannot unhook D3D12, this might crash.");
        }

        m_valid = false;
        m_is_d3d12 = false;

        // Try to hook d3d11 instead
        return hook_d3d11();
    }

    return false;
}

Framework::~Framework() {
    spdlog::info("Framework shutting down...");

    m_terminating = true;
    m_d3d_monitor_thread->request_stop();
    m_command_thread->request_stop();
    if (m_d3d_monitor_thread->joinable()) {
        m_d3d_monitor_thread->join();
    }

    if (m_command_thread->joinable()) {
        m_command_thread->join();
    }

    if (m_is_d3d11) {
        deinit_d3d11();
    }

    if (m_is_d3d12) {
        deinit_d3d12();
    }

    ImGui_ImplWin32_Shutdown();

    if (m_initialized) {
        ImGui::DestroyContext();
    }
}

void Framework::run_imgui_frame(bool from_present) {
    std::scoped_lock _{ m_imgui_mtx };

    m_has_frame = false;

    if (!m_initialized) {
        return;
    }

    const bool is_init_ok = m_error.empty() && m_game_data_initialized;

    consume_input();
    update_fonts();
    
    ImGui_ImplWin32_NewFrame();

    // from_present is so we don't accidentally
    // run script/game code within the present thread.
    if (is_init_ok && !from_present) {
        // Run mod frame callbacks.
        m_mods->on_pre_imgui_frame();
    }

    ImGui::NewFrame();

    if (!from_present) {
        call_on_frame();
    }

    draw_ui();
    m_last_draw_ui = m_draw_ui;

    ImGui::EndFrame();
    ImGui::Render();

    m_has_frame = true;
}

// D3D11 Draw funciton
void Framework::on_frame_d3d11() {
    std::scoped_lock _{ m_imgui_mtx };

    spdlog::debug("on_frame (D3D11)");

    m_renderer_type = RendererType::D3D11;

    if (!m_initialized) {
        if (!initialize()) {
            spdlog::error("Failed to initialize Framework on DirectX 11");
            return;
        }

        spdlog::info("Framework initialized");
        m_initialized = true;
        return;
    }

    if (m_message_hook_requested) {
        initialize_windows_message_hook();
        initialize_xinput_hook();
        initialize_dinput_hook();
    }

    auto device = m_d3d11_hook->get_device();
    
    if (device == nullptr) {
        spdlog::error("D3D11 device was null when it shouldn't be, returning...");
        m_initialized = false;
        return;
    }

    bool is_init_ok = first_frame_initialize();

    //if (!m_has_frame) {
        //if (!is_init_ok) {
            //update_fonts();
            invalidate_device_objects();

            ImGui_ImplDX11_NewFrame();
            // hooks don't run until after initialization, so we just render the imgui window while initalizing.
            if (!m_has_engine_thread) {
                run_imgui_frame(false);
            }
   /*     } else {   
            return;
        }
    } else {
        invalidate_device_objects();
        ImGui_ImplDX11_NewFrame();
    }*/

    if (is_init_ok) {
        m_mods->on_present();
    }

    if (auto draw_data = ImGui::GetDrawData(); draw_data != nullptr) {
        ComPtr<ID3D11DeviceContext> context{};
        float clear_color[]{0.0f, 0.0f, 0.0f, 0.0f};
    
        m_d3d11_hook->get_device()->GetImmediateContext(&context);
        context->ClearRenderTargetView(m_d3d11.blank_rt_rtv.Get(), clear_color);
        context->ClearRenderTargetView(m_d3d11.rt_rtv.Get(), clear_color);
        context->OMSetRenderTargets(1, m_d3d11.rt_rtv.GetAddressOf(), NULL);
        ImGui_ImplDX11_RenderDrawData(draw_data);
    
        for (auto& mod : m_mods->get_mods()) {
            mod->on_post_render_vr_framework_dx11(context.Get(), m_d3d11.rt.Get(), m_d3d11.rt_rtv.Get());
        }
    
        // Set the back buffer to be the render target.
        context->OMSetRenderTargets(1, m_d3d11.bb_rtv.GetAddressOf(), nullptr);
        ImGui_ImplDX11_RenderDrawData(draw_data);
    }

    if (is_init_ok) {
        m_mods->on_post_frame();
    }
}

void Framework::on_post_present_d3d11() {
    if (!m_error.empty() || !m_initialized || !m_game_data_initialized) {
        if (m_last_present_time <= std::chrono::steady_clock::now()){
            m_last_present_time = std::chrono::steady_clock::now();
        }

        return;
    }

    for (auto& mod : m_mods->get_mods()) {
        mod->on_post_present();
    }

    if (m_last_present_time <= std::chrono::steady_clock::now()){
        m_last_present_time = std::chrono::steady_clock::now();
    }
}

// D3D12 Draw funciton
void Framework::on_frame_d3d12() {
    std::scoped_lock _{ m_imgui_mtx };

    m_renderer_type = RendererType::D3D12;

    auto command_queue = m_d3d12_hook->get_command_queue();
    //spdlog::debug("on_frame (D3D12)");
    
    if (!m_initialized) {
        if (!initialize()) {
            spdlog::error("Failed to initialize Framework on DirectX 12");
            return;
        }

        spdlog::info("Framework initialized");
        m_initialized = true;
        return;
    }

    if (command_queue == nullptr) {
        spdlog::error("Null Command Queue");
        return;
    }

    if (m_message_hook_requested) {
        initialize_windows_message_hook();
        initialize_xinput_hook();
        initialize_dinput_hook();
    }

    auto device = m_d3d12_hook->get_device();

    if (device == nullptr) {
        spdlog::error("D3D12 Device was null when it shouldn't be, returning...");
        m_initialized = false;
        return;
    }

    bool is_init_ok = first_frame_initialize();

    //if (!m_has_frame) {
        //if (!is_init_ok) {
            //update_fonts();

            ImGui::GetIO().BackendRendererUserData = m_d3d12.imgui_backend_datas[0];
            const auto prev_cleanup = m_wants_device_object_cleanup;
            invalidate_device_objects();
            ImGui_ImplDX12_NewFrame();

            ImGui::GetIO().BackendRendererUserData = m_d3d12.imgui_backend_datas[1];
            m_wants_device_object_cleanup = prev_cleanup;
            invalidate_device_objects();
            ImGui_ImplDX12_NewFrame();
            // hooks don't run until after initialization, so we just render the imgui window while initalizing.
            if (!m_has_engine_thread) {
                run_imgui_frame(false);
            }
    /*    } else {   
            return;
        }
    } else {
        invalidate_device_objects();
        ImGui_ImplDX12_NewFrame();
    }*/

    if (is_init_ok) {
        m_mods->on_present();
    }

    if (m_d3d12.cmd_ctxs.empty()) {
        return;
    }

    auto& cmd_ctx = m_d3d12.cmd_ctxs[m_d3d12.cmd_ctx_index++ % m_d3d12.cmd_ctxs.size()];

    if (cmd_ctx == nullptr) {
        return;
    }

    cmd_ctx->wait(INFINITE);
    if (auto draw_data = ImGui::GetDrawData(); draw_data != nullptr) {
        std::scoped_lock _{ cmd_ctx->mtx };
        cmd_ctx->has_commands = true;

        // Draw to our render target.
        D3D12_RESOURCE_BARRIER barrier{};
        barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
        barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
        barrier.Transition.pResource = m_d3d12.get_rt(D3D12::RTV::IMGUI).Get();
        barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
        barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
        barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
        cmd_ctx->cmd_list->ResourceBarrier(1, &barrier);

        float clear_color[]{0.0f, 0.0f, 0.0f, 0.0f};
        D3D12_CPU_DESCRIPTOR_HANDLE rts[1]{};
        cmd_ctx->cmd_list->ClearRenderTargetView(m_d3d12.get_cpu_rtv(device, D3D12::RTV::IMGUI), clear_color, 0, nullptr);
        rts[0] = m_d3d12.get_cpu_rtv(device, D3D12::RTV::IMGUI);
        cmd_ctx->cmd_list->OMSetRenderTargets(1, rts, FALSE, NULL);
        cmd_ctx->cmd_list->SetDescriptorHeaps(1, m_d3d12.srv_desc_heap.GetAddressOf());

        ImGui::GetIO().BackendRendererUserData = m_d3d12.imgui_backend_datas[1];
        ImGui_ImplDX12_RenderDrawData(draw_data, cmd_ctx->cmd_list.Get());

        for (auto& mod : m_mods->get_mods()) {
            rts[0] = m_d3d12.get_cpu_rtv(device, D3D12::RTV::IMGUI);
            mod->on_post_render_vr_framework_dx12(cmd_ctx->cmd_list.Get(), m_d3d12.get_rt(D3D12::RTV::IMGUI).Get(), &rts[0]);
        }
        
        barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
        barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
        cmd_ctx->cmd_list->ResourceBarrier(1, &barrier);

        // Draw to the back buffer.
        auto swapchain = m_d3d12_hook->get_swap_chain();
        auto bb_index = swapchain->GetCurrentBackBufferIndex();
        barrier.Transition.pResource = m_d3d12.rts[bb_index].Get();
        barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
        barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
        cmd_ctx->cmd_list->ResourceBarrier(1, &barrier);
        rts[0] = m_d3d12.get_cpu_rtv(device, (D3D12::RTV)bb_index);
        cmd_ctx->cmd_list->OMSetRenderTargets(1, rts, FALSE, NULL);
        cmd_ctx->cmd_list->SetDescriptorHeaps(1, m_d3d12.srv_desc_heap.GetAddressOf());

        ImGui::GetIO().BackendRendererUserData = m_d3d12.imgui_backend_datas[0];
        ImGui_ImplDX12_RenderDrawData(draw_data, cmd_ctx->cmd_list.Get());

        barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
        barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
        cmd_ctx->cmd_list->ResourceBarrier(1, &barrier);

        cmd_ctx->execute();
    }

    if (is_init_ok) {
        m_mods->on_post_frame();
    }
}

void Framework::on_post_present_d3d12() {
    if (!m_error.empty() || !m_initialized || !m_game_data_initialized) {
        if (m_last_present_time <= std::chrono::steady_clock::now()){
            m_last_present_time = std::chrono::steady_clock::now();
        }

        return;
    }
    
    for (auto& mod : m_mods->get_mods()) {
        mod->on_post_present();
    }

    if (m_last_present_time <= std::chrono::steady_clock::now()){
        m_last_present_time = std::chrono::steady_clock::now();
    }
}

void Framework::on_reset(uint32_t w, uint32_t h) {
    std::scoped_lock _{ m_imgui_mtx };

    spdlog::info("Reset! {} {}", w, h);

    if (m_initialized) {
        // fixes text boxes not being able to receive input
        imgui::reset_keystates();
    }

    // Crashes if we don't release it at this point.
    if (m_is_d3d11) {
        deinit_d3d11();
        m_d3d11.rt_width = w;
        m_d3d11.rt_height = h;
    }

    if (m_is_d3d12) {
        deinit_d3d12();
        m_d3d12.rt_width = w;
        m_d3d12.rt_height = h;
    }

    if (m_game_data_initialized) {
        m_mods->on_device_reset();
    }

    m_has_frame = false;
    m_first_initialize = false;
    m_initialized = false;
}

void Framework::activate_window() {
    if (m_wnd == nullptr) {
        return;
    }

    AllowSetForegroundWindow(GetCurrentProcessId());
    SetForegroundWindow(m_wnd);
    //BringWindowToTop(m_wnd);
    //SetFocus(m_wnd);
    //SetActiveWindow(m_wnd);
}

void Framework::patch_set_cursor_pos() {
    std::scoped_lock _{ m_patch_mtx };

    if (m_set_cursor_pos_patch.get() == nullptr) {
        // Make SetCursorPos ret early
        const auto set_cursor_pos_addr = (uintptr_t)GetProcAddress(GetModuleHandleA("user32.dll"), "SetCursorPos");

        if (set_cursor_pos_addr != 0) {
            spdlog::info("Patching SetCursorPos");
            m_set_cursor_pos_patch = Patch::create(set_cursor_pos_addr, {0xC3});
        }
    }
}

void Framework::remove_set_cursor_pos_patch() {
    std::scoped_lock _{ m_patch_mtx };

    if (m_set_cursor_pos_patch.get() != nullptr) {
        spdlog::info("Removing SetCursorPos patch");
    }

    m_set_cursor_pos_patch.reset();
}

void Framework::set_mouse_to_center() {
    if (m_wnd == nullptr) {
        return;
    }

    RECT rect{};
    GetWindowRect(m_wnd, &rect);

    int x = (rect.left + rect.right) / 2;
    int y = (rect.top + rect.bottom) / 2;

    if (m_set_cursor_pos_patch != nullptr) {
        remove_set_cursor_pos_patch();
        SetCursorPos(x, y);
        patch_set_cursor_pos();
    } else {
        SetCursorPos(x, y);
    }
}

void Framework::post_message(UINT message, WPARAM w_param, LPARAM l_param) {
    if (m_wnd == nullptr) {
        return;
    }

    PostMessage(m_wnd, message, w_param, l_param);
}

bool Framework::on_message(HWND wnd, UINT message, WPARAM w_param, LPARAM l_param) {
    m_last_message_time = std::chrono::steady_clock::now();

    if (!m_initialized) {
        return true;
    }

    // If we called is_filtered during a WM_GETTEXT message we would deadlock.
    if (message != WM_GETTEXT && !WindowFilter::get().is_filtered(wnd)) {
        m_uevr_shared_memory->data().main_thread_id = GetCurrentThreadId();
    }

    bool is_mouse_moving{false};
    switch (message) {
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        if (w_param >= 0 && w_param < 256) {
            m_last_keys[w_param] = true;
        }

        if (w_param == VK_INSERT ||
            w_param == FrameworkConfig::get()->get_menu_key()->value()) 
        {
            set_draw_ui(!m_draw_ui, true);
            return false;
        }
        break;
    case WM_KEYUP:
    case WM_SYSKEYUP:
        if (w_param >= 0 && w_param < 256) {
            m_last_keys[w_param] = false;
        }
        break;
    case WM_KILLFOCUS:
        std::fill(std::begin(m_last_keys), std::end(m_last_keys), false);
        break;
    case WM_SETFOCUS:
        std::fill(std::begin(m_last_keys), std::end(m_last_keys), false);
        break;
    case WM_ACTIVATE:
        if (LOWORD(w_param) == WA_INACTIVE) {
            return false;
        }
        break;
    case WM_INPUT: {
        // RIM_INPUT means the window has focus
        /*if (GET_RAWINPUT_CODE_WPARAM(w_param) == RIM_INPUT) {
            uint32_t size = sizeof(RAWINPUT);
            RAWINPUT raw{};
            
            // obtain size
            GetRawInputData((HRAWINPUT)l_param, RID_INPUT, nullptr, &size, sizeof(RAWINPUTHEADER));

            auto result = GetRawInputData((HRAWINPUT)l_param, RID_INPUT, &raw, &size, sizeof(RAWINPUTHEADER));

            if (raw.header.dwType == RIM_TYPEMOUSE) {
                m_accumulated_mouse_delta[0] += (float)raw.data.mouse.lLastX;
                m_accumulated_mouse_delta[1] += (float)raw.data.mouse.lLastY;

                // Allowing camera movement when the UI is hovered while not focused
                if (raw.data.mouse.lLastX || raw.data.mouse.lLastY) {
                    is_mouse_moving = true;
                }
            }
        }*/
    } break;

    default:
        break;
    }

    ImGui_ImplWin32_WndProcHandler(wnd, message, w_param, l_param);

    {
        // If the user is interacting with the UI we block the message from going to the game.
        const auto& io = ImGui::GetIO();
        if (m_draw_ui && !m_ui_passthrough) {
            // Fix of a bug that makes the input key down register but the key up will never register
            // when clicking on the ui while the game is not focused
            if (message == WM_INPUT && GET_RAWINPUT_CODE_WPARAM(w_param) == RIM_INPUTSINK){
                return false;
            }

            static std::unordered_set<UINT> forcefully_allowed_messages {
                WM_DEVICECHANGE, // Allows XInput devices to connect to UE
                WM_SHOWWINDOW,
                WM_ACTIVATE,
                WM_ACTIVATEAPP,
                WM_CLOSE,
                WM_DPICHANGED,
                WM_SIZING,
                WM_MOUSEACTIVATE
            };

            if (!forcefully_allowed_messages.contains(message)) {      
                if (m_is_ui_focused) {
                    if (io.WantCaptureMouse || io.WantCaptureKeyboard || io.WantTextInput)
                        return false;
                } else {
                    if (!is_mouse_moving && (io.WantCaptureMouse || io.WantCaptureKeyboard || io.WantTextInput))
                        return false;
                }
            }
        }
    }

    bool any_false = false;

    if (m_game_data_initialized) {
        for (auto& mod : m_mods->get_mods()) {
            if (!mod->on_message(wnd, message, w_param, l_param)) {
                any_false = true;
            }
        }
    }

    return !any_false;
}

void Framework::on_frontend_command(uevrSharedMemory::Command command) {
    spdlog::info("Received frontend command: {}", (int)command);

    switch (command) {
    case uevrSharedMemory::Command::RELOAD_CONFIG:
        m_frame_worker->enqueue([this]() {
            m_mods->reload_config();
        });

        break;
    case uevrSharedMemory::Command::CONFIG_SETUP_ACKNOWLEDGED:
        m_uevr_shared_memory->data().signal_frontend_config_setup = false;
        break;
    case uevrSharedMemory::Command::QUIT:
        if (m_wnd != nullptr) {
            PostMessageA(m_wnd, WM_CLOSE, 0, 0);
            PostMessageA(m_wnd, WM_DESTROY, 0, 0);
            PostMessageA(m_wnd, WM_QUIT, 0, 0);
            m_terminating = true;
        }
        
        break;
    default:
        spdlog::error("Unknown frontend command received: {}", (int)command);
        break;
    }
}

// this is unfortunate.
void Framework::on_direct_input_keys(const std::array<uint8_t, 256>& keys) {
    /*const auto menu_key = FrameworkConfig::get()->get_menu_key()->value();

    if (keys[menu_key] && m_last_keys[menu_key] == 0) {
        std::lock_guard _{m_input_mutex};

        set_draw_ui(!m_draw_ui);
    }

    m_last_keys = keys;*/
}

std::filesystem::path Framework::get_persistent_dir() {
    auto return_appdata_dir = []() -> std::filesystem::path {
        wchar_t app_data_path[MAX_PATH]{};
        SHGetSpecialFolderPathW(0, app_data_path, CSIDL_APPDATA, false);

        const auto exe_name = [&]() {
            const auto result = std::filesystem::path(*utility::get_module_pathw(utility::get_executable())).stem().string();
            const auto dir = std::filesystem::path(app_data_path) / "UnrealVRMod" / result;
            std::filesystem::create_directories(dir);

            return result;
        }();

        return std::filesystem::path(app_data_path) / "UnrealVRMod" / exe_name;
    };

    static const auto result = return_appdata_dir();

    return result;
}

void Framework::save_config() {
    std::scoped_lock _{m_config_mtx};

    spdlog::info("Saving config config.txt");

    utility::Config cfg{};

    for (auto& mod : m_mods->get_mods()) {
        mod->on_config_save(cfg);
    }

    if (!cfg.save(get_persistent_dir("config.txt").string())) {
        spdlog::info("Failed to save config");
        return;
    }

    spdlog::info("Saved config");

    if (auto& sm = g_framework->get_shared_memory(); sm) {
        sm->data().signal_frontend_config_setup = true;
        spdlog::info("Signaled frontend config setup");
    }
}

void Framework::reset_config() try {
    std::scoped_lock _{m_config_mtx};

    m_mods->reload_config(true);

    spdlog::info("Removed config");
} catch (const std::exception& e) {
    spdlog::error("Failed to reset config: {}", e.what());
}

void Framework::reload_config() try {
    std::scoped_lock _{m_config_mtx};

    m_mods->reload_config(false);

    spdlog::info("Reloaded config");
} catch (const std::exception& e) {
    spdlog::error("Failed to reload config: {}", e.what());
}

bool Framework::is_drawing_anything() const {
    return m_draw_ui || FrameworkConfig::get()->is_always_show_cursor();
}

void Framework::set_draw_ui(bool state, bool should_save) {
    std::scoped_lock _{m_config_mtx};

    spdlog::info("Setting draw ui to {}", state);

    bool prev_state = m_draw_ui;
    m_draw_ui = state;

    if (m_game_data_initialized) {
        FrameworkConfig::get()->get_menu_open()->value() = state;
    }

    if (state != prev_state && should_save && m_game_data_initialized) {
        save_config();
    }
}

void Framework::consume_input() {
    m_mouse_delta[0] = m_accumulated_mouse_delta[0];
    m_mouse_delta[1] = m_accumulated_mouse_delta[1];

    m_accumulated_mouse_delta[0] = 0.0f;
    m_accumulated_mouse_delta[1] = 0.0f;
}

int Framework::add_font(const std::filesystem::path& filepath, int size, const std::vector<ImWchar>& ranges) {
    // Look for a font already matching this description.
    for (int i = 0; i < m_additional_fonts.size(); ++i) {
        const auto& font = m_additional_fonts[i];

        if (font.filepath == filepath && font.size == size && font.ranges == ranges) {
            return i;
        }
    }

    m_additional_fonts.emplace_back(Framework::AdditionalFont{filepath, size, ranges, (ImFont*)nullptr});
    m_fonts_need_updating = true;

    return m_additional_fonts.size() - 1;
}

void Framework::update_fonts() {
    if (!m_fonts_need_updating) {
        return;
    }

    m_fonts_need_updating = false;

    auto& fonts = ImGui::GetIO().Fonts;

    fonts->Clear();
    fonts->AddFontFromMemoryCompressedTTF(RobotoMedium_compressed_data, RobotoMedium_compressed_size, (float)m_font_size);

    for (auto& font : m_additional_fonts) {
        const ImWchar* ranges = nullptr;

        if (!font.ranges.empty()) {
            ranges = font.ranges.data();
        }

        if (fs::exists(font.filepath)) {
            font.font = fonts->AddFontFromFileTTF(font.filepath.string().c_str(), (float)font.size, nullptr, ranges);
        } else {
            font.font = fonts->AddFontFromMemoryCompressedTTF(RobotoMedium_compressed_data, RobotoMedium_compressed_size, (float)font.size, nullptr, ranges);
        }
    }

    fonts->Build();
    m_wants_device_object_cleanup = true;
}

void Framework::invalidate_device_objects() {
    if (!m_wants_device_object_cleanup) {
        return;
    }

    if (m_renderer_type == RendererType::D3D11) {
        ImGui_ImplDX11_InvalidateDeviceObjects();
    } else if (m_renderer_type == RendererType::D3D12) {
        ImGui_ImplDX12_InvalidateDeviceObjects();
    }

    m_wants_device_object_cleanup = false;
}

void Framework::draw_ui() {
    std::lock_guard _{m_input_mutex};

    if (m_current_theme != get_imgui_theme_value()) {
        set_imgui_style();
        m_current_theme = get_imgui_theme_value();
    }

    ImGui::GetIO().MouseDrawCursor = m_draw_ui || FrameworkConfig::get()->is_always_show_cursor();
    ImGui::GetIO().ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange; // causes bugs with the cursor

    if (!m_draw_ui) {
        // remove SetCursorPos patch
        if (!FrameworkConfig::get()->is_always_show_cursor()) {
            remove_set_cursor_pos_patch();
        } else {
            patch_set_cursor_pos();
        }

        m_is_ui_focused = false;
        if (m_last_draw_ui) {
            m_windows_message_hook->window_toggle_cursor(m_cursor_state);
        }
        //m_dinput_hook->acknowledge_input();
        // ImGui::GetIO().MouseDrawCursor = false;
        return;
    }
    
    // UI Specific code:
    m_is_ui_focused = ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow);

    if (m_ui_option_transparent) {
        auto& style = ImGui::GetStyle();
        if (m_is_ui_focused) {
            style.Alpha = 1.0f;
        } else {
            if (ImGui::IsWindowHovered(ImGuiFocusedFlags_AnyWindow)) {
                style.Alpha = 0.9f;
            } else {
                style.Alpha = 0.8f;
            }
        }
    } else {
        auto& style = ImGui::GetStyle();
        style.Alpha = 1.0f;
    }

    auto& io = ImGui::GetIO();

    if (io.WantCaptureKeyboard) {
        //m_dinput_hook->ignore_input();
    } else {
        //m_dinput_hook->acknowledge_input();
    }

    const auto is_vr_active = VR::get()->is_hmd_active();


    // Center the window
    const auto rt_size = get_rt_size();
    constexpr auto window_w = 700.0f;
    constexpr auto window_h = 700.0f;

    const auto centered_x = (rt_size.x / 2) - (window_w / 2);
    const auto centered_y = (rt_size.y / 2) - (window_h / 2);

    // Always re-center the UI upon open if VR is active
    if (is_vr_active && !m_last_draw_ui) {
        ImGui::SetNextWindowPos(ImVec2(centered_x, centered_y), ImGuiCond_Always);
    } else {
        ImGui::SetNextWindowPos(ImVec2(centered_x, centered_y), ImGuiCond_Once);
    }

    if (!m_last_draw_ui || m_cursor_state_changed) {
        m_cursor_state_changed = false;
    }
    
    static const auto uevr_NAME = std::format("uevr [{}+{}-{:.8}]", uevr_TAG, uevr_COMMITS_PAST_TAG, uevr_COMMIT_HASH);

    ImGui::SetNextWindowSize(ImVec2(window_w, window_h), ImGuiCond_::ImGuiCond_Once);
    ImGui::Begin(uevr_NAME.c_str(), &m_draw_ui);

    ImGui::BeginGroup();
    ImGui::Columns(2);
    ImGui::BeginGroup();

    ImGui::Checkbox("Transparency", &m_ui_option_transparent);
    ImGui::SameLine();
    ImGui::Text("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Makes the UI transparent when not focused.");
    }
    ImGui::Checkbox("Input Passthrough", &m_ui_passthrough);
    ImGui::SameLine();
    ImGui::Text("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Allows mouse and keyboard inputs to register to the game while the UI is focused.");
    }

    FrameworkConfig::get()->get_advanced_mode()->draw("Show Advanced Options");

    ImGui::SameLine();
    ImGui::Text("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Show additional options for greater control over various settings.");
    }

    if (m_mods_fully_initialized) {
        if (ImGui::Button("Reset to Default Settings")) {
            reset_config();
        }
    }

    ImGui::EndGroup();
    ImGui::NextColumn();

    ImGui::BeginGroup();
    ImGui::Text("Keyboard Menu Key: Insert");
    ImGui::Text("Gamepad L3 + R3: Toggle Menu");
    ImGui::Text("Gamepad RT: Shortcuts");
    ImGui::Text("Gamepad LB/RB: Change Sidebar Page");

    ImGui::EndGroup();
    ImGui::EndGroup();

    ImGui::Columns(1);

    // Mods:
    auto& sidebar_entries = m_sidebar_state.entries;
    sidebar_entries.clear();
    sidebar_entries.emplace_back("About", false);

    if (ImGui::BeginTable("uevrTable", 2, ImGuiTableFlags_::ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_::ImGuiTableFlags_BordersOuterV | ImGuiTableFlags_::ImGuiTableFlags_SizingFixedFit)) {
        ImGui::TableSetupColumn("uevrLeftPaneColumn", ImGuiTableColumnFlags_WidthFixed, 150.0f);
        ImGui::TableSetupColumn("uevrRightPaneColumn", ImGuiTableColumnFlags_WidthStretch);

        ImGui::TableNextRow();
        ImGui::TableSetColumnIndex(0); // Set to the first column

        ImGui::BeginChild("uevrLeftPane", ImVec2(0, 0), true);
        auto dcs = [&](const char* label, int32_t page_value) -> bool {
            ImGui::PushStyleVar(ImGuiStyleVar_SelectableTextAlign, ImVec2(0.5f, 0.5f));
            if (ImGui::Selectable(label, m_sidebar_state.selected_entry == page_value)) {
                m_sidebar_state.selected_entry = page_value;
                ImGui::PopStyleVar();
                return true;
            }
            ImGui::PopStyleVar();
            return false;
        };

        dcs("About", 0);

        if (m_error.empty() && m_game_data_initialized) {
            struct Info {
                size_t mn{};
                size_t mx{};
                std::shared_ptr<Mod> mod{};
                bool has_sidebar_entries{};
            };

            std::vector<Info> mod_sidebar_ranges{};

            const auto is_advanced_mode = is_advanced_view_enabled();

            for (auto& mod : m_mods->get_mods()) {
                if (mod->is_advanced_mod() && !is_advanced_mode) {
                    continue;
                }

                auto entries = mod->get_sidebar_entries();

                if (!entries.empty()) {
                    size_t displayed_entries = 0;
                    for (auto& entry : entries) {
                        if (entry.m_advanced_entry && !is_advanced_mode) {
                            continue;
                        }

                        sidebar_entries.emplace_back(entry.m_label.c_str(), entry.m_advanced_entry);
                        ++displayed_entries;
                    }

                    if (displayed_entries > 0) {
                        mod_sidebar_ranges.push_back(Info{sidebar_entries.size() - displayed_entries, sidebar_entries.size(), mod, true});
                    }
                } else {
                    mod_sidebar_ranges.push_back(Info{sidebar_entries.size(), sidebar_entries.size() + 1, mod, false});
                    sidebar_entries.emplace_back(mod->get_name().data(), mod->is_advanced_mod());
                }
            }

            for (size_t i = 1; i < sidebar_entries.size(); ++i) {
                if (is_advanced_mode || !sidebar_entries[i].m_advanced_entry) {
                    for (const auto& range : mod_sidebar_ranges) {
                        if (i == range.mn) {
                            // Set first entry as default ("Runtime" entry of VR mod)
                            if (range.has_sidebar_entries && !m_sidebar_state.initialized) {
                                if (range.mod->get_name() == "VR") {
                                    m_sidebar_state.selected_entry = i;
                                    m_sidebar_state.initialized = true;
                                    ImGui::SetWindowFocus("uevrRightPane");
                                }
                            }

                            ImGui::Text(range.mod->get_name().data());
                        }
                    }

                    ImGui::PushID(i);
                    dcs(sidebar_entries[i].m_label.c_str(), i);
                    ImGui::PopID();
                }
            }

            bool wants_focus_right = false;

            if (ImGui::IsKeyPressed(ImGuiKey_GamepadL1)) {
                decrement_sidebar_page();
                wants_focus_right = true;
            }

            if (ImGui::IsKeyPressed(ImGuiKey_GamepadR1)) {
                increment_sidebar_page();
                wants_focus_right = true;
            }

            if (m_sidebar_state.selected_entry < 0) {
                m_sidebar_state.selected_entry = sidebar_entries.size() - 1;
            }

            m_sidebar_state.selected_entry = m_sidebar_state.selected_entry % sidebar_entries.size();

            ImGui::EndChild();
            ImGui::TableNextColumn(); // Move to the next column (right)

            if (wants_focus_right) {
                ImGui::SetNextWindowFocus();
            }

            ImGui::BeginChild("uevrRightPane", ImVec2(0, 0), true, ImGuiWindowFlags_::ImGuiWindowFlags_AlwaysUseWindowPadding);
            {
                ImGui::BeginGroup();

                if (m_sidebar_state.selected_entry > 0) {
                    // Find the mod that owns this entry
                    for (const auto& range : mod_sidebar_ranges) {
                        if (m_sidebar_state.selected_entry >= range.mn && m_sidebar_state.selected_entry < range.mx) {
                            if (wants_focus_right) {
                                ImGui::SetKeyboardFocusHere();
                            }

                            if (range.has_sidebar_entries) {
                                range.mod->on_draw_sidebar_entry(sidebar_entries[m_sidebar_state.selected_entry].m_label);
                            } else {
                                range.mod->on_draw_ui();
                            }

                            break;
                        }
                    }
                } else {
                    draw_about();
                }

                ImGui::EndGroup();
                ImGui::EndChild();
            }

            /*for (auto& mod : m_mods->get_mods()) {
                mod->on_draw_ui();
            }*/

            //m_mods->on_draw_ui();
        } else if (!m_game_data_initialized) {
            ImGui::EndChild();

            if (m_sidebar_state.selected_entry == 0) {
                ImGui::TableNextColumn();
                draw_about();
            }

            ImGui::TextWrapped("Framework is currently initializing...");
            ImGui::TextWrapped("This menu will close after initialization if you have the remember option enabled.");
        } else if (!m_error.empty()) {
            ImGui::EndChild();

            if (m_sidebar_state.selected_entry == 0) {
                ImGui::TableNextColumn();
                draw_about();
            }

            ImGui::TextWrapped("Framework error: %s", m_error.c_str());
        }

        ImGui::EndTable();
    }

    m_last_window_pos = ImGui::GetWindowPos();
    m_last_window_size = ImGui::GetWindowSize();

    ImGui::End();

    // save the menu state in config
    if (m_draw_ui != m_last_draw_ui) {
        if (m_draw_ui) {
            set_mouse_to_center();
            patch_set_cursor_pos();
        }

        m_draw_ui = m_last_draw_ui;
        set_draw_ui(!m_draw_ui, true);
    }

    // if we pressed the X button to close the menu.
    if (m_last_draw_ui && !m_draw_ui) {
        m_windows_message_hook->window_toggle_cursor(m_cursor_state);
    }
}

void Framework::draw_about() {
    ImGui::Text("Author: praydog");
    ImGui::Text("Unreal Engine VR");
    ImGui::Text("https://github.com/praydog/uevr");
    ImGui::Text("http://praydog.com");
    ImGui::Text("Branch: %s", uevr_BRANCH);
    ImGui::Text("Commits: %i", uevr_TOTAL_COMMITS);
    ImGui::Text("Commit hash: %s", std::format("{:.8}", uevr_COMMIT_HASH).c_str());
    ImGui::Text("Tag: %s", uevr_TAG);
    ImGui::Text("Commits past tag: %i", uevr_COMMITS_PAST_TAG);
    ImGui::Text("Build date: %s", uevr_BUILD_DATE);
    ImGui::Text("Build time: %s", uevr_BUILD_TIME);

    if (ImGui::CollapsingHeader("Licenses")) {
        ImGui::TreePush("Licenses");

        struct License {
            std::string name;
            std::string text;
        };

        static std::array<License, 10> licenses{
            License{ "glm", license::glm },
            License{ "imgui", license::imgui },
            License{ "safetyhook", license::safetyhook },
            License{ "spdlog", license::spdlog },
            License{ "json", license::json },
            License{ "bddisasm", utility::narrow(license::bddisasm) },
            License{ "directxtk", license::directxtk },
            License{ "directxtk12", license::directxtk },
            License{ "openvr", license::openvr },
            License{ "openxr", license::openxr }
        };

        for (const auto& license : licenses) {
            if (ImGui::CollapsingHeader(license.name.c_str())) {
                ImGui::TextWrapped(license.text.c_str());
            }
        }

        ImGui::TreePop();
    }

    ImGui::Separator();
}

void Framework::set_imgui_style() noexcept {
    
    auto current_theme = get_imgui_theme_value();
    
    switch (current_theme) {
        case ImGuiThemes::DEFAULT_DARK:
            ImGuiThemeHelper::StyleColorsDefaultDark();
            break;
        case ImGuiThemes::ALTERNATIVE_DARK:
            ImGuiThemeHelper::StyleColorsAlternativeDark();
            break;
        case ImGuiThemes::DEFAULT_LIGHT:
            ImGuiThemeHelper::StyleColorsDefaultLight();
            break;
        case ImGuiThemes::HIGH_CONTRAST:
            ImGuiThemeHelper::StyleColorsHighContrast();
            break;
        default:
            ImGuiThemeHelper::StyleColorsDefaultDark();
            break;
    }
    
    // Font
    set_font_size(m_font_size);

    ImGui::GetIO().ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange;
}

bool Framework::initialize() {
    if (m_initialized) {
        return true;
    }

    framework::setup_exception_handler();

    if (m_first_initialize) {
        m_frames_since_init = 0;
        m_first_initialize = false;
    }

    if (m_frames_since_init < 60) {
        m_frames_since_init++;
        return false;
    }

    if (m_is_d3d11) {
        spdlog::info("Attempting to initialize DirectX 11");

        if (!m_d3d11_hook->is_hooked()) {
            return false;
        }

        auto device = m_d3d11_hook->get_device();
        auto swap_chain = m_d3d11_hook->get_swap_chain();

        // Wait.
        if (device == nullptr || swap_chain == nullptr) {
            m_first_initialize = true;

            spdlog::info("Device or SwapChain null. DirectX 12 may be in use. Unhooking D3D11...");

            // We unhook D3D11
            if (m_d3d11_hook->unhook()) {
                spdlog::info("D3D11 unhooked!");
            } else {
                spdlog::error("Cannot unhook D3D11, this might crash.");
            }

            m_is_d3d11 = false;
            m_valid = false;

            // We hook D3D12
            if (!hook_d3d12()) {
                spdlog::error("Failed to hook D3D12 after unhooking D3D11.");
            }
            return false;
        }

        ID3D11DeviceContext* context = nullptr;
        device->GetImmediateContext(&context);

        DXGI_SWAP_CHAIN_DESC swap_desc{};
        swap_chain->GetDesc(&swap_desc);

        m_wnd = swap_desc.OutputWindow;


        spdlog::info("Window Handle: {0:x}", (uintptr_t)m_wnd);
        spdlog::info("Initializing ImGui");

        IMGUI_CHECKVERSION();
        ImGui::CreateContext();

        set_imgui_style();

        static const auto imgui_ini = (get_persistent_dir() / "imgui.ini").string();
        ImGui::GetIO().IniFilename = imgui_ini.c_str();

        spdlog::info("Initializing ImGui Win32");

        if (!ImGui_ImplWin32_Init(m_wnd)) {
            spdlog::error("Failed to initialize ImGui.");
            return false;
        }

        spdlog::info("Creating render target");

        if (!init_d3d11()) {
            spdlog::error("Failed to init D3D11");
            return false;
        }
    } else if (m_is_d3d12) {
        spdlog::info("Attempting to initialize DirectX 12");

        if (!m_d3d12_hook->is_hooked()) {
            return false;
        }

        auto device = m_d3d12_hook->get_device();
        auto swap_chain = m_d3d12_hook->get_swap_chain();

        if (device == nullptr || swap_chain == nullptr) {
            m_first_initialize = true;

            spdlog::info("Device: {:x}", (uintptr_t)device);
            spdlog::info("SwapChain: {:x}", (uintptr_t)swap_chain);

            spdlog::info("Device or SwapChain null. DirectX 11 may be in use. Unhooking D3D12...");

            // We unhook D3D12
            if (m_d3d12_hook->unhook())
                spdlog::info("D3D12 unhooked!");
            else
                spdlog::error("Cannot unhook D3D12, this might crash.");

            m_valid = false;
            m_is_d3d12 = false;

            // We hook D3D11
            if (!hook_d3d11()) {
                spdlog::error("Failed to hook D3D11 after unhooking D3D12.");
            }
            return false;
        }

        DXGI_SWAP_CHAIN_DESC swap_desc{};
        swap_chain->GetDesc(&swap_desc);

        m_wnd = swap_desc.OutputWindow;


        IMGUI_CHECKVERSION();
        ImGui::CreateContext();

        set_imgui_style();

        static const auto imgui_ini = (get_persistent_dir() / "imgui.ini").string();
        ImGui::GetIO().IniFilename = imgui_ini.c_str();
        
        if (!ImGui_ImplWin32_Init(m_wnd)) {
            spdlog::error("Failed to initialize ImGui ImplWin32.");
            return false;
        }

        if (!init_d3d12()) {
            spdlog::error("Failed to init D3D12.");
            return false;
        }
    } else {
        return false;
    }

    initialize_windows_message_hook();
    initialize_xinput_hook();
    initialize_dinput_hook();

    if (m_first_frame) {
        m_first_frame = false;

        spdlog::info("Starting game data initialization thread");

        m_mods = std::make_unique<Mods>();

        // Game specific initialization stuff. Code that runs any D3D must not run here (like VR code).
        // This originally used a thread but that was determined to be unnecessary.
        // All D3D code runs in a separate on_initialize_d3d_thread call for each mod.
        // All mod on_initialize code is not heavy enough to warrant a thread.
        try {
            auto e = m_mods->on_initialize();

            if (e) {
                if (e->empty()) {
                    m_error = "An unknown error has occurred.";
                } else {
                    m_error = *e;
                }

                spdlog::error("Initialization of mods failed. Reason: {}", m_error);
            }
            

            m_game_data_initialized = true;
        } catch(...) {
            m_error = "An exception has occurred during initialization.";
            m_game_data_initialized = true;
            spdlog::error("Initialization of mods failed. Reason: exception thrown.");
        }
    }

    return true;
}

bool Framework::initialize_windows_message_hook() {
    if (m_wnd == 0) {
        return false;
    }

    if (m_first_frame || m_message_hook_requested || m_windows_message_hook == nullptr) {
        m_last_message_time = std::chrono::steady_clock::now();
        m_windows_message_hook.reset();
        m_windows_message_hook = std::make_unique<WindowsMessageHook>(m_wnd);
        m_windows_message_hook->on_message = [this](auto wnd, auto msg, auto w_param, auto l_param) {
            return on_message(wnd, msg, w_param, l_param);
        };

        m_message_hook_requested = false;
        return true;
    }

    m_message_hook_requested = false;
    return false;
}

bool Framework::initialize_xinput_hook() {
    if (m_first_frame || m_xinput_hook == nullptr) {
        m_xinput_hook.reset();
        m_xinput_hook = std::make_unique<XInputHook>();
    }

    return true;
}

bool Framework::initialize_dinput_hook() {
    if (m_first_frame || m_dinput_hook == nullptr) {
        m_dinput_hook.reset();
        m_dinput_hook = std::make_unique<DInputHook>();
    }

    return true;
}

// Ran on the first valid frame after pre-initialization of mods has taken place and hasn't failed
// This one allows mods to run any initialization code in the context of the D3D thread (like VR code)
// It also is the one that actually loads any config files
bool Framework::first_frame_initialize() {
    const bool is_init_ok = m_error.empty() && m_game_data_initialized;

    if (!is_init_ok || !m_first_frame_d3d_initialize) {
        return is_init_ok;
    }

    std::scoped_lock _{get_hook_monitor_mutex()};

    spdlog::info("Running first frame D3D initialization of mods...");

    m_first_frame_d3d_initialize = false;
    auto e = m_mods->on_initialize_d3d_thread();

    if (e) {
        if (e->empty()) {
            m_error = "An unknown error has occurred.";
        } else {
            m_error = *e;
        }

        spdlog::error("Initialization of mods failed. Reason: {}", m_error);
        m_game_data_initialized = false;
        m_mods_fully_initialized = false;
        return false;
    } else {
        // Do an initial config save to set the default values for the frontend
        save_config();
        m_mods_fully_initialized = true;
    }

    return true;
}

void Framework::call_on_frame() {
    const bool is_init_ok = m_error.empty() && m_game_data_initialized && m_mods_fully_initialized;

    if (is_init_ok) {
        // Run mod frame callbacks.
        m_frame_worker->execute();
        m_mods->on_frame();
    }
}

// DirectX 11 Initialization methods

bool Framework::init_d3d11() {
    deinit_d3d11();

    auto swapchain = m_d3d11_hook->get_swap_chain();
    auto device = m_d3d11_hook->get_device();

    // Get back buffer.
    spdlog::info("[D3D11] Creating RTV of back buffer...");

    ComPtr<ID3D11Texture2D> backbuffer{};

    if (FAILED(swapchain->GetBuffer(0, IID_PPV_ARGS(&backbuffer)))) {
        spdlog::error("[D3D11] Failed to get back buffer!");
        return false;
    }

    // Create a render target view of the back buffer.
    if (FAILED(device->CreateRenderTargetView(backbuffer.Get(), nullptr, &m_d3d11.bb_rtv))) {
        spdlog::error("[D3D11] Failed to create back buffer render target view!");
        return false;
    }

    // Get backbuffer description.
    D3D11_TEXTURE2D_DESC backbuffer_desc{};

    backbuffer->GetDesc(&backbuffer_desc);
    backbuffer_desc.BindFlags |= D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE;

    spdlog::info("[D3D11] Back buffer format is {}", backbuffer_desc.Format);

    spdlog::info("[D3D11] Creating render targets...");
    {
        // Create our blank render target.
        auto d3d11_rt_desc = backbuffer_desc;
        d3d11_rt_desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM; // For VR

        if (FAILED(device->CreateTexture2D(&d3d11_rt_desc, nullptr, &m_d3d11.blank_rt))) {
            spdlog::error("[D3D11] Failed to create render target texture!");
            return false;
        }

        // Create our render target
        if (FAILED(device->CreateTexture2D(&d3d11_rt_desc, nullptr, &m_d3d11.rt))) {
            spdlog::error("[D3D11] Failed to create render target texture!");
            return false;
        }
    }

    // Create our blank render target view.
    spdlog::info("[D3D11] Creating rtvs...");

    if (FAILED(device->CreateRenderTargetView(m_d3d11.blank_rt.Get(), nullptr, &m_d3d11.blank_rt_rtv))) {
        spdlog::error("[D3D11] Failed to create render terget view!");
        return false;
    }


    // Create our render target view.
    if (FAILED(device->CreateRenderTargetView(m_d3d11.rt.Get(), nullptr, &m_d3d11.rt_rtv))) {
        spdlog::error("[D3D11] Failed to create render terget view!");
        return false;
    }

    // Create our render target shader resource view.
    spdlog::info("[D3D11] Creating srvs...");

    if (FAILED(device->CreateShaderResourceView(m_d3d11.rt.Get(), nullptr, &m_d3d11.rt_srv))) {
        spdlog::error("[D3D11] Failed to create shader resource view!");
        return false;
    }

    m_d3d11.rt_width = backbuffer_desc.Width;
    m_d3d11.rt_height = backbuffer_desc.Height;
    m_last_rt_size = {backbuffer_desc.Width, backbuffer_desc.Height};

    spdlog::info("[D3D11] Initializing ImGui D3D11...");

    ComPtr<ID3D11DeviceContext> context{};

    device->GetImmediateContext(&context);

    if (!ImGui_ImplDX11_Init(device, context.Get())) {
        spdlog::error("[D3D11] Failed to initialize ImGui.");
        return false;
    }

    return true;
}

void Framework::deinit_d3d11() {
    ImGui_ImplDX11_Shutdown();
    m_d3d11 = {};
}

// DirectX 12 Initialization methods

bool Framework::init_d3d12() {
    deinit_d3d12();
    
    auto device = m_d3d12_hook->get_device();

    spdlog::info("[D3D12] Creating command allocator...");

    m_d3d12.cmd_ctxs.clear();

    for (auto i = 0; i < 3; ++i) {
        auto& ctx = m_d3d12.cmd_ctxs.emplace_back(std::make_unique<d3d12::CommandContext>());

        if (!ctx->setup(L"Framework::m_d3d12.cmd_ctx")) {
            spdlog::error("[D3D12] Failed to create command context.");
            return false;
        }
    }

    spdlog::info("[D3D12] Creating RTV descriptor heap...");

    {
        D3D12_DESCRIPTOR_HEAP_DESC desc{};

        desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
        desc.NumDescriptors = (int)D3D12::RTV::COUNT; 
        desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
        desc.NodeMask = 1;

        if (FAILED(device->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&m_d3d12.rtv_desc_heap)))) {
            spdlog::error("[D3D12] Failed to create RTV descriptor heap.");
            return false;
        }

        m_d3d12.rtv_desc_heap->SetName(L"Framework::m_d3d12.rtv_desc_heap");
    }

    spdlog::info("[D3D12] Creating SRV descriptor heap...");

    { 
        D3D12_DESCRIPTOR_HEAP_DESC desc{};
        
        desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
        desc.NumDescriptors = (int)D3D12::SRV::COUNT;
        desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

        if (FAILED(device->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&m_d3d12.srv_desc_heap)))) {
            spdlog::error("[D3D12] Failed to create SRV descriptor heap.");
            return false;
        }

        m_d3d12.srv_desc_heap->SetName(L"Framework::m_d3d12.srv_desc_heap");
    }

    spdlog::info("[D3D12] Creating render targets...");

    {
        // Create back buffer rtvs.
        auto swapchain = m_d3d12_hook->get_swap_chain();

        DXGI_SWAP_CHAIN_DESC swap_desc{};
        swapchain->GetDesc(&swap_desc);

        for (auto i = 0; i < swap_desc.BufferCount; ++i) {
            if (i > (int)D3D12::RTV::BACKBUFFER_8) {
                spdlog::warn("[D3D12] Swap chain has more back buffers than we support. Stopping at 8.");
                break; // assume max
            }

            if (SUCCEEDED(swapchain->GetBuffer(i, IID_PPV_ARGS(&m_d3d12.rts[i])))) {
                device->CreateRenderTargetView(m_d3d12.rts[i].Get(), nullptr, m_d3d12.get_cpu_rtv(device, (D3D12::RTV)i));
            } else {
                spdlog::error("[D3D12] Failed to get back buffer for rtv.");
                break; // assume max
            }
        }

        // Create our imgui and blank rts.
        auto& backbuffer = m_d3d12.get_rt(D3D12::RTV::BACKBUFFER_0);
        auto desc = backbuffer->GetDesc();

        spdlog::info("[D3D12] Back buffer format is {}", desc.Format);

        D3D12_HEAP_PROPERTIES props{};
        props.Type = D3D12_HEAP_TYPE_DEFAULT;
        props.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN;
        props.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN;

        auto d3d12_rt_desc = desc;
        d3d12_rt_desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM; // For VR

        D3D12_CLEAR_VALUE clear_value{};
        clear_value.Format = d3d12_rt_desc.Format;

        if (FAILED(device->CreateCommittedResource(&props, D3D12_HEAP_FLAG_NONE, &d3d12_rt_desc, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, &clear_value,
                IID_PPV_ARGS(&m_d3d12.get_rt(D3D12::RTV::IMGUI))))) {
            spdlog::error("[D3D12] Failed to create the imgui render target.");
            return false;
        }

        m_d3d12.get_rt(D3D12::RTV::IMGUI)->SetName(L"Framework::m_d3d12.rts[IMGUI]");

        if (FAILED(device->CreateCommittedResource(&props, D3D12_HEAP_FLAG_NONE, &d3d12_rt_desc, D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE, &clear_value,
                IID_PPV_ARGS(&m_d3d12.get_rt(D3D12::RTV::BLANK))))) {
            spdlog::error("[D3D12] Failed to create the blank render target.");
            return false;
        }

        m_d3d12.get_rt(D3D12::RTV::BLANK)->SetName(L"Framework::m_d3d12.rts[BLANK]");

        // Create imgui and blank rtvs and srvs.
        device->CreateRenderTargetView(m_d3d12.get_rt(D3D12::RTV::IMGUI).Get(), nullptr, m_d3d12.get_cpu_rtv(device, D3D12::RTV::IMGUI));
        device->CreateRenderTargetView(m_d3d12.get_rt(D3D12::RTV::BLANK).Get(), nullptr, m_d3d12.get_cpu_rtv(device, D3D12::RTV::BLANK));
        device->CreateShaderResourceView(
            m_d3d12.get_rt(D3D12::RTV::IMGUI).Get(), nullptr, m_d3d12.get_cpu_srv(device, D3D12::SRV::IMGUI_VR));
        device->CreateShaderResourceView(m_d3d12.get_rt(D3D12::RTV::BLANK).Get(), nullptr, m_d3d12.get_cpu_srv(device, D3D12::SRV::BLANK));

        m_d3d12.rt_width = (uint32_t)desc.Width;
        m_d3d12.rt_height = (uint32_t)desc.Height;

        m_last_rt_size = {desc.Width, desc.Height};
    }

    spdlog::info("[D3D12] Initializing ImGui...");

    auto& bb = m_d3d12.get_rt(D3D12::RTV::BACKBUFFER_0);
    auto bb_desc = bb->GetDesc();

    if (!ImGui_ImplDX12_Init(device, 3, bb_desc.Format, m_d3d12.srv_desc_heap.Get(),
            m_d3d12.get_cpu_srv(device, D3D12::SRV::IMGUI_FONT_BACKBUFFER), m_d3d12.get_gpu_srv(device, D3D12::SRV::IMGUI_FONT_BACKBUFFER))) {
        spdlog::error("[D3D12] Failed to initialize ImGui.");
        return false;
    }

    m_d3d12.imgui_backend_datas[0] = ImGui::GetIO().BackendRendererUserData;

    ImGui::GetIO().BackendRendererUserData = nullptr;

    // Now initialize another one for the VR texture.
    auto& bb_vr = m_d3d12.get_rt(D3D12::RTV::IMGUI);
    auto bb_vr_desc = bb_vr->GetDesc();

    if (!ImGui_ImplDX12_Init(device, 3, bb_vr_desc.Format, m_d3d12.srv_desc_heap.Get(),
            m_d3d12.get_cpu_srv(device, D3D12::SRV::IMGUI_FONT_VR), m_d3d12.get_gpu_srv(device, D3D12::SRV::IMGUI_FONT_VR))) {
        spdlog::error("[D3D12] Failed to initialize ImGui.");
        return false;
    }

    m_d3d12.imgui_backend_datas[1] = ImGui::GetIO().BackendRendererUserData;

    return true;
}

void Framework::deinit_d3d12() {
    for (auto& ctx : m_d3d12.cmd_ctxs) {
        if (ctx != nullptr) {
            ctx->reset();
        }
    }

    m_d3d12.cmd_ctxs.clear();

    for (auto userdata : m_d3d12.imgui_backend_datas) {
        if (userdata != nullptr) {
            ImGui::GetIO().BackendRendererUserData = userdata;
            ImGui_ImplDX12_Shutdown();
        }
    }

    ImGui::GetIO().BackendRendererUserData = nullptr;
    m_d3d12 = {};
}

bool Framework::is_advanced_view_enabled() const {
    return FrameworkConfig::get()->is_advanced_mode();
}

Framework::ImGuiThemes Framework::get_imgui_theme_value() const {
    return static_cast<ImGuiThemes>(FrameworkConfig::get()->get_imgui_theme_value());
}
`

---
## ðŸ“ Framework.hpp
**Sti:** $filePath  
**StÃ¸rrelse:** 13358 bytes  
**Sidst Ã¦ndret:** 2025-08-19 03:01:40

### ðŸ”— Includes
`cpp
#include <array>
`

### ðŸ—ï¸ Classes
`cpp
class UEVRSharedMemory {
`

### âš™ï¸ Functions
`cpp
void hook_monitor()
`

### ðŸ“„ Komplet Indhold
`cpp
#pragma once

#include <array>
#include <unordered_set>
#include <filesystem>

#include <spdlog/spdlog.h>
#include <imgui.h>

#include <utility/Address.hpp>
#include <sdk/Math.hpp>
#include <utility/Patch.hpp>

#include <sdk/threading/ThreadWorker.hpp>
#include <mods/vr/d3d12/CommandContext.hpp>

class Mods;

#include "hooks/D3D11Hook.hpp"
#include "hooks/D3D12Hook.hpp"
#include "hooks/WindowsMessageHook.hpp"
#include "hooks/XInputHook.hpp"
#include "hooks/DInputHook.hpp"

class UEVRSharedMemory {
public:
    static inline int MESSAGE_IDENTIFIER = *(int*)"VRMOD";

    enum Command {
        RELOAD_CONFIG = 0,
        CONFIG_SETUP_ACKNOWLEDGED = 1,
        QUIT = 2,
    };

public:
    UEVRSharedMemory();

    virtual ~UEVRSharedMemory() {
        UnmapViewOfFile(m_data);
        CloseHandle(m_memory);
    }

    #pragma pack(push, 1)
    struct Data {
        wchar_t path[MAX_PATH]{}; // Path to the game exe
        uint32_t pid{}; // Process ID of the game
        uint32_t main_thread_id{}; // Main thread ID of the game
        uint32_t command_thread_id{}; // Thread ID commands are sent to (via PostThreadMessage)
        bool signal_frontend_config_setup{false};
    };
    #pragma pack(pop)

    Data& data() {
        return *m_data;
    }

private:
    HANDLE m_memory{};
    Data* m_data{};
};

struct SidebarEntryInfo {
    SidebarEntryInfo(std::string_view label, bool advanced) : m_label(label), m_advanced_entry(advanced) {}

    std::string m_label{};
    bool m_advanced_entry{false};
};

// Global facilitator
class Framework {
private:
    void hook_monitor();
    void command_thread();

public:
    Framework(HMODULE framework_module);
    virtual ~Framework();

    auto get_framework_module() const { return m_framework_module; }

    bool is_valid() const { return m_valid; }

    bool is_dx11() const { return m_is_d3d11; }

    bool is_dx12() const { return m_is_d3d12; }

    const auto& get_mods() const { return m_mods; }

    const auto& get_mouse_delta() const { return m_mouse_delta; }
    const auto& get_keyboard_state() const { return m_last_keys; }

    Address get_module() const { return m_game_module; }

    bool is_ready() const { return m_initialized && m_game_data_initialized; }
    bool is_game_data_intialized() const { return m_game_data_initialized; }

    void run_imgui_frame(bool from_present);

    void on_frame_d3d11();
    void on_post_present_d3d11();
    void on_frame_d3d12();
    void on_post_present_d3d12();
    
    void on_reset(uint32_t w, uint32_t h);

    void activate_window();
    void set_mouse_to_center();
    void patch_set_cursor_pos();
    void remove_set_cursor_pos_patch();
    void post_message(UINT message, WPARAM w_param, LPARAM l_param);
    bool on_message(HWND wnd, UINT message, WPARAM w_param, LPARAM l_param);

    void on_frontend_command(UEVRSharedMemory::Command command);
    void on_direct_input_keys(const std::array<uint8_t, 256>& keys);

    static std::filesystem::path get_persistent_dir();
    static std::filesystem::path get_persistent_dir(const std::string& dir) {
        return get_persistent_dir() / dir;
    }

    void deferred_save_config() {
        m_frame_worker->enqueue([this]() {
            save_config();
        });
    }

    void deferred_reload_config() {
        m_frame_worker->enqueue([this]() {
            reload_config();
        });
    }

    void save_config();
    void reset_config();
    void reload_config();

    enum class RendererType : uint8_t {
        D3D11,
        D3D12
    };
    
    auto get_renderer_type() const { return m_renderer_type; }
    auto& get_d3d11_hook() const { return m_d3d11_hook; }
    auto& get_d3d12_hook() const { return m_d3d12_hook; }

    auto get_window() const { return m_wnd; }
    auto get_last_window_pos() const { return m_last_window_pos; } // Framework imgui window
    auto get_last_window_size() const { return m_last_window_size; } // Framework imgui window

    bool is_drawing_ui() const {
        return m_draw_ui;
    }

    bool is_drawing_anything() const;

    void set_draw_ui(bool state, bool should_save = true);

    auto& get_hook_monitor_mutex() {
        return m_hook_monitor_mutex;
    }

    void set_font_size(int size) { 
        if (m_font_size != size) {
            m_font_size = size;
            m_fonts_need_updating = true;
        }
    }

    auto get_font_size() const { return m_font_size; }

    int add_font(const std::filesystem::path& filepath, int size, const std::vector<ImWchar>& ranges = {});

    ImFont* get_font(int index) const {
        if (index >= 0 && index < m_additional_fonts.size()) {
            return m_additional_fonts[index].font;
        }
        
        return nullptr;
    }

    Vector2f get_d3d11_rt_size() const {
        return m_last_rt_size;
    }

    Vector2f get_d3d12_rt_size() const {
        return m_last_rt_size;
    }

    Vector2f get_rt_size() const {
        if (get_renderer_type() == RendererType::D3D11) {
            return get_d3d11_rt_size();
        }

        return get_d3d12_rt_size();
    }

    auto& get_frame_worker() {
        return m_frame_worker;
    }

    auto& get_shared_memory() {
        return m_uevr_shared_memory;
    }

    void enable_engine_thread() {
        m_has_engine_thread = true;
    }

    void increment_sidebar_page() {
        const auto now = std::chrono::steady_clock::now();
        const auto delta = now - m_last_page_inc_time;
        if (delta < std::chrono::milliseconds(100)) {
            return;
        }

        ++m_sidebar_state.selected_entry;
        m_last_page_inc_time = now;
    }

    void decrement_sidebar_page() {
        const auto now = std::chrono::steady_clock::now();
        const auto delta = now - m_last_page_dec_time;
        if (delta < std::chrono::milliseconds(100)) {
            return;
        }

        --m_sidebar_state.selected_entry;
        m_last_page_dec_time = now;
    }

    bool is_advanced_view_enabled() const;

    enum ImGuiThemes : int8_t {
        DEFAULT_DARK,
        ALTERNATIVE_DARK,
        DEFAULT_LIGHT,
        HIGH_CONTRAST,
    };
    
    ImGuiThemes get_imgui_theme_value() const;

private:
    void consume_input();
    void update_fonts();
    void invalidate_device_objects();

private:
    void draw_ui();
    void draw_about();

    bool hook_d3d11();
    bool hook_d3d12();

    bool initialize();
    bool initialize_windows_message_hook();
    bool initialize_xinput_hook();
    bool initialize_dinput_hook();

    bool first_frame_initialize();

    void call_on_frame();

    HMODULE m_framework_module{};

    bool m_first_frame{true};
    bool m_first_frame_d3d_initialize{true};
    bool m_is_d3d12{false};
    bool m_is_d3d11{false};
    bool m_valid{false};
    bool m_initialized{false};
    bool m_created_default_cfg{false};
    std::atomic<bool> m_terminating{false};
    std::atomic<bool> m_game_data_initialized{false};
    std::atomic<bool> m_mods_fully_initialized{false};
    
    // UI
    bool m_has_frame{false};
    bool m_wants_device_object_cleanup{false};
    bool m_draw_ui{true};
    bool m_last_draw_ui{m_draw_ui};
    bool m_is_ui_focused{false};
    bool m_cursor_state{false};
    bool m_cursor_state_changed{true};
    bool m_ui_option_transparent{true};
    bool m_ui_passthrough{false};
    
    ImVec2 m_last_window_pos{};
    ImVec2 m_last_window_size{};
    Vector2f m_last_rt_size{1920, 1080};

    ImGuiThemes m_current_theme;

    struct AdditionalFont {
        std::filesystem::path filepath{};
        int size{16};
        std::vector<ImWchar> ranges{};
        ImFont* font{};
    };

    bool m_fonts_need_updating{true};
    int m_font_size{16};
    std::vector<AdditionalFont> m_additional_fonts{};

    std::recursive_mutex m_input_mutex{};
    std::recursive_mutex m_config_mtx{};
    std::recursive_mutex m_imgui_mtx{};
    std::recursive_mutex m_patch_mtx{};

    HWND m_wnd{0};
    HMODULE m_game_module{0};

    float m_accumulated_mouse_delta[2]{};
    float m_mouse_delta[2]{};
    std::array<uint8_t, 256> m_last_keys{0};
    std::unique_ptr<D3D11Hook> m_d3d11_hook{};
    std::unique_ptr<D3D12Hook> m_d3d12_hook{};
    std::unique_ptr<WindowsMessageHook> m_windows_message_hook{};
    std::unique_ptr<XInputHook> m_xinput_hook{};
    std::unique_ptr<DInputHook> m_dinput_hook{};
    std::shared_ptr<spdlog::logger> m_logger{};
    std::unique_ptr<UEVRSharedMemory> m_uevr_shared_memory{};
    Patch::Ptr m_set_cursor_pos_patch{};

    std::unique_ptr<ThreadWorker<void>> m_frame_worker{ std::make_unique<ThreadWorker<void>>() };

    std::string m_error{""};

    // Game-specific stuff
    std::unique_ptr<Mods> m_mods;

    std::recursive_mutex m_hook_monitor_mutex{};
    std::recursive_mutex m_constructor_mutex{};
    std::unique_ptr<std::jthread> m_d3d_monitor_thread{};
    std::unique_ptr<std::jthread> m_command_thread{};
    std::chrono::steady_clock::time_point m_last_present_time{};
    std::chrono::steady_clock::time_point m_last_message_time{};
    std::chrono::steady_clock::time_point m_last_sendmessage_time{};
    std::chrono::steady_clock::time_point m_last_chance_time{};
    std::chrono::steady_clock::time_point m_last_page_dec_time{};
    std::chrono::steady_clock::time_point m_last_page_inc_time{};
    uint32_t m_frames_since_init{0};
    bool m_has_last_chance{true};
    bool m_first_initialize{true};

    bool m_sent_message{false};
    bool m_message_hook_requested{false};
    bool m_has_engine_thread{false};

    RendererType m_renderer_type{RendererType::D3D11};

    struct {
        int32_t selected_entry{0};
        bool initialized{false};

        std::vector<SidebarEntryInfo> entries{};
    } m_sidebar_state{};

    template <typename T> using ComPtr = Microsoft::WRL::ComPtr<T>;

private: // D3D misc
    void set_imgui_style() noexcept;

private: // D3D11 Init
    bool init_d3d11();
    void deinit_d3d11();

private: // D3D12 Init
    bool init_d3d12();
    void deinit_d3d12();

private: // D3D11 members
    struct D3D11 {
        ComPtr<ID3D11Texture2D> blank_rt{};
		ComPtr<ID3D11Texture2D> rt{};
        ComPtr<ID3D11RenderTargetView> blank_rt_rtv{};
		ComPtr<ID3D11RenderTargetView> rt_rtv{};
		ComPtr<ID3D11ShaderResourceView> rt_srv{};
        uint32_t rt_width{};
        uint32_t rt_height{};
		ComPtr<ID3D11RenderTargetView> bb_rtv{};
    } m_d3d11{};

public:
    auto& get_blank_rendertarget_d3d11() { return m_d3d11.blank_rt; }
    auto& get_rendertarget_d3d11() { return m_d3d11.rt; }
    auto get_rendertarget_width_d3d11() const { return m_d3d11.rt_width; }
    auto get_rendertarget_height_d3d11() const { return m_d3d11.rt_height; }

private: // D3D12 members
    struct D3D12 {
        std::vector<std::unique_ptr<d3d12::CommandContext>> cmd_ctxs{};
        uint32_t cmd_ctx_index{0};

        enum class RTV : int{
            BACKBUFFER_0,
            BACKBUFFER_1,
            BACKBUFFER_2,
            BACKBUFFER_3,
            BACKBUFFER_4,
            BACKBUFFER_5,
            BACKBUFFER_6,
            BACKBUFFER_7,
            BACKBUFFER_8,
            IMGUI,
            BLANK,
            COUNT,
        };

        enum class SRV : int {
            IMGUI_FONT_BACKBUFFER,
            IMGUI_FONT_VR,
            IMGUI_VR,
            BLANK,
            COUNT
        };

        ComPtr<ID3D12DescriptorHeap> rtv_desc_heap{};
        ComPtr<ID3D12DescriptorHeap> srv_desc_heap{};
        ComPtr<ID3D12Resource> rts[(int)RTV::COUNT]{};

        auto& get_rt(RTV rtv) { return rts[(int)rtv]; }

        D3D12_CPU_DESCRIPTOR_HANDLE get_cpu_rtv(ID3D12Device* device, RTV rtv) {
            return {rtv_desc_heap->GetCPUDescriptorHandleForHeapStart().ptr +
                    (SIZE_T)rtv * (SIZE_T)device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV)};
        }

        D3D12_CPU_DESCRIPTOR_HANDLE get_cpu_srv(ID3D12Device* device, SRV srv) {
            return {srv_desc_heap->GetCPUDescriptorHandleForHeapStart().ptr +
                    (SIZE_T)srv * (SIZE_T)device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)};
        }

        D3D12_GPU_DESCRIPTOR_HANDLE get_gpu_srv(ID3D12Device* device, SRV srv) {
            return {srv_desc_heap->GetGPUDescriptorHandleForHeapStart().ptr +
                    (SIZE_T)srv * (SIZE_T)device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)};
        }

        uint32_t rt_width{};
        uint32_t rt_height{};

        std::array<void*, 2> imgui_backend_datas{};
    } m_d3d12{};

public:
    auto& get_blank_rendertarget_d3d12() { return m_d3d12.get_rt(D3D12::RTV::BLANK); }
    auto& get_rendertarget_d3d12() { return m_d3d12.get_rt(D3D12::RTV::IMGUI); }
    auto get_rendertarget_width_d3d12() { return m_d3d12.rt_width; }
    auto get_rendertarget_height_d3d12() { return m_d3d12.rt_height; }

private:
};

extern std::unique_ptr<Framework> g_framework;

`

---
## ðŸ“ Main.cpp
**Sti:** $filePath  
**StÃ¸rrelse:** 531 bytes  
**Sidst Ã¦ndret:** 2025-08-18 19:28:41

### ðŸ”— Includes
`cpp
#include <windows.h>
`

### ðŸ—ï¸ Classes
`cpp

`

### âš™ï¸ Functions
`cpp
void startup_thread(HMODULE poc_module)
`

### ðŸ“„ Komplet Indhold
`cpp
// dllmain
#include <windows.h>
#include <cstdint>
#include <spdlog/spdlog.h>
#include <spdlog/sinks/basic_file_sink.h>

#include <utility/Thread.hpp>

#include "Framework.hpp"

void startup_thread(HMODULE poc_module) {
    g_framework = std::make_unique<Framework>(poc_module);
}

BOOL APIENTRY DllMain(HANDLE handle, DWORD reason, LPVOID reserved) {
    if (reason == DLL_PROCESS_ATTACH) {
        CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)startup_thread, handle, 0, nullptr);
    }

    return TRUE;
}
`

---
## ðŸ“ Mod.cpp
**Sti:** $filePath  
**StÃ¸rrelse:** 5868 bytes  
**Sidst Ã¦ndret:** 2025-08-18 19:28:41

### ðŸ”— Includes
`cpp
#include "Mod.hpp"
`

### ðŸ—ï¸ Classes
`cpp

`

### âš™ï¸ Functions
`cpp

`

### ðŸ“„ Komplet Indhold
`cpp
#include "Mod.hpp"

std::unordered_map<int, std::string> ModKey::keycodes{
    {VK_LBUTTON, "Left mouse button"},
    {VK_RBUTTON, "Right mouse button"},
    {VK_CANCEL, "Control-break processing"},
    {VK_MBUTTON, "Middle mouse button (three-button mouse)"},
    {VK_XBUTTON1, "X1 mouse button"},
    {VK_XBUTTON2, "X2 mouse button"},
    {VK_BACK, "BACKSPACE key"},
    {VK_TAB, "TAB key"},
    {VK_CLEAR, "CLEAR key"},
    {VK_RETURN, "ENTER key"},
    {VK_SHIFT, "SHIFT key"},
    {VK_CONTROL, "CTRL key"},
    {VK_MENU, "ALT key"},
    {VK_PAUSE, "PAUSE key"},
    {VK_CAPITAL, "CAPS LOCK key"},
    {VK_KANA, "IME Kana mode"},
    {VK_HANGUL, "IME Hangul mode"},
    {VK_IME_ON, "IME On"},
    {VK_JUNJA, "IME Junja mode"},
    {VK_FINAL, "IME final mode"},
    {VK_HANJA, "IME Hanja mode"},
    {VK_KANJI, "IME Kanji mode"},
    {VK_IME_OFF, "IME Off"},
    {VK_ESCAPE, "ESC key"},
    {VK_CONVERT, "IME convert"},
    {VK_NONCONVERT, "IME nonconvert"},
    {VK_ACCEPT, "IME accept"},
    {VK_MODECHANGE, "IME mode change request"},
    {VK_SPACE, "SPACEBAR"},
    {VK_PRIOR, "PAGE UP key"},
    {VK_NEXT, "PAGE DOWN key"},
    {VK_END, "END key"},
    {VK_HOME, "HOME key"},
    {VK_LEFT, "LEFT ARROW key"},
    {VK_UP, "UP ARROW key"},
    {VK_RIGHT, "RIGHT ARROW key"},
    {VK_DOWN, "DOWN ARROW key"},
    {VK_SELECT, "SELECT key"},
    {VK_PRINT, "PRINT key"},
    {VK_EXECUTE, "EXECUTE key"},
    {VK_SNAPSHOT, "PRINT SCREEN key"},
    {VK_INSERT, "INS key"},
    {VK_DELETE, "DEL key"},
    {VK_HELP, "HELP key"},
    {0x30, "0 key"},
    {0x31, "1 key"},
    {0x32, "2 key"},
    {0x33, "3 key"},
    {0x34, "4 key"},
    {0x35, "5 key"},
    {0x36, "6 key"},
    {0x37, "7 key"},
    {0x38, "8 key"},
    {0x39, "9 key"},
    {0x41, "A key"},
    {0x42, "B key"},
    {0x43, "C key"},
    {0x44, "D key"},
    {0x45, "E key"},
    {0x46, "F key"},
    {0x47, "G key"},
    {0x48, "H key"},
    {0x49, "I key"},
    {0x4A, "J key"},
    {0x4B, "K key"},
    {0x4C, "L key"},
    {0x4D, "M key"},
    {0x4E, "N key"},
    {0x4F, "O key"},
    {0x50, "P key"},
    {0x51, "Q key"},
    {0x52, "R key"},
    {0x53, "S key"},
    {0x54, "T key"},
    {0x55, "U key"},
    {0x56, "V key"},
    {0x57, "W key"},
    {0x58, "X key"},
    {0x59, "Y key"},
    {0x5A, "Z key"},
    {VK_LWIN, "Left Windows key (Natural keyboard)"},
    {VK_RWIN, "Right Windows key (Natural keyboard)"},
    {VK_APPS, "Applications key (Natural keyboard)"},
    {VK_SLEEP, "Computer Sleep key"},
    {VK_NUMPAD0, "Numeric keypad 0 key"},
    {VK_NUMPAD1, "Numeric keypad 1 key"},
    {VK_NUMPAD2, "Numeric keypad 2 key"},
    {VK_NUMPAD3, "Numeric keypad 3 key"},
    {VK_NUMPAD4, "Numeric keypad 4 key"},
    {VK_NUMPAD5, "Numeric keypad 5 key"},
    {VK_NUMPAD6, "Numeric keypad 6 key"},
    {VK_NUMPAD7, "Numeric keypad 7 key"},
    {VK_NUMPAD8, "Numeric keypad 8 key"},
    {VK_NUMPAD9, "Numeric keypad 9 key"},
    {VK_MULTIPLY, "Multiply key"},
    {VK_ADD, "Add key"},
    {VK_SEPARATOR, "Separator key"},
    {VK_SUBTRACT, "Subtract key"},
    {VK_DECIMAL, "Decimal key"},
    {VK_DIVIDE, "Divide key"},
    {VK_F1, "F1 key"},
    {VK_F2, "F2 key"},
    {VK_F3, "F3 key"},
    {VK_F4, "F4 key"},
    {VK_F5, "F5 key"},
    {VK_F6, "F6 key"},
    {VK_F7, "F7 key"},
    {VK_F8, "F8 key"},
    {VK_F9, "F9 key"},
    {VK_F10, "F10 key"},
    {VK_F11, "F11 key"},
    {VK_F12, "F12 key"},
    {VK_F13, "F13 key"},
    {VK_F14, "F14 key"},
    {VK_F15, "F15 key"},
    {VK_F16, "F16 key"},
    {VK_F17, "F17 key"},
    {VK_F18, "F18 key"},
    {VK_F19, "F19 key"},
    {VK_F20, "F20 key"},
    {VK_F21, "F21 key"},
    {VK_F22, "F22 key"},
    {VK_F23, "F23 key"},
    {VK_F24, "F24 key"},
    {VK_NUMLOCK, "NUM LOCK key"},
    {VK_SCROLL, "SCROLL LOCK key"},
    {VK_LSHIFT, "Left SHIFT key"},
    {VK_RSHIFT, "Right SHIFT key"},
    {VK_LCONTROL, "Left CONTROL key"},
    {VK_RCONTROL, "Right CONTROL key"},
    {VK_LMENU, "Left ALT key"},
    {VK_RMENU, "Right ALT key"},
    {VK_BROWSER_BACK, "Browser Back key"},
    {VK_BROWSER_FORWARD, "Browser Forward key"},
    {VK_BROWSER_REFRESH, "Browser Refresh key"},
    {VK_BROWSER_STOP, "Browser Stop key"},
    {VK_BROWSER_SEARCH, "Browser Search key"},
    {VK_BROWSER_FAVORITES, "Browser Favorites key"},
    {VK_BROWSER_HOME, "Browser Start and Home key"},
    {VK_VOLUME_MUTE, "Volume Mute key"},
    {VK_VOLUME_DOWN, "Volume Down key"},
    {VK_VOLUME_UP, "Volume Up key"},
    {VK_MEDIA_NEXT_TRACK, "Next Track key"},
    {VK_MEDIA_PREV_TRACK, "Previous Track key"},
    {VK_MEDIA_STOP, "Stop Media key"},
    {VK_LAUNCH_MAIL, "Start Mail key"},
    {VK_LAUNCH_MEDIA_SELECT, "Select Media key"},
    {VK_LAUNCH_APP1, "Start Application 1 key"},
    {VK_LAUNCH_APP2, "Start Application 2 key"},
    {VK_OEM_1, "OEM 1 key (varies by keyboard layout, usually ';:' or ',<')"},
    {VK_OEM_PLUS, "OEM Plus key (usually '+')"},
    {VK_OEM_COMMA, "OEM Comma key (usually ',')"},
    {VK_OEM_MINUS, "OEM Minus key (usually '-')"},
    {VK_OEM_PERIOD, "OEM Period key (usually '.')"},
    {VK_OEM_2, "OEM 2 key"},
    {VK_OEM_3, "OEM 3 key"}, 
    {VK_OEM_4, "OEM 4 key"}, 
    {VK_OEM_5, "OEM 5 key"}, 
    {VK_OEM_6, "OEM 6 key"}, 
    {VK_OEM_7, "OEM 7 key"},
    {VK_OEM_8, "OEM 8 key"},
    {VK_OEM_102, "OEM 102 key (on some European keyboards, '<>' or '|')"},
    {VK_PROCESSKEY, "IME PROCESS key"},
    {VK_PACKET, "Used to pass Unicode characters as keystrokes"},
    {VK_ATTN, "Attn key"},
    {VK_CRSEL, "CrSel key"},
    {VK_EXSEL, "ExSel key"},
    {VK_EREOF, "Erase EOF key"},
    {VK_PLAY, "Play key"},
    {VK_ZOOM, "Zoom key"},
    {VK_NONAME, "Reserved (no name)"},
    {VK_PA1, "PA1 key"},
    {VK_OEM_CLEAR, "OEM Clear key"},
};
`

---
## ðŸ“ Mod.hpp
**Sti:** $filePath  
**StÃ¸rrelse:** 21568 bytes  
**Sidst Ã¦ndret:** 2025-08-18 19:28:41

### ðŸ”— Includes
`cpp
#include <vector>
`

### ðŸ—ï¸ Classes
`cpp
class IModValue {
`

### âš™ï¸ Functions
`cpp
void draw_value(std::string_view name)
`

### ðŸ“„ Komplet Indhold
`cpp
#pragma once

#include <vector>
#include <windows.h>
#include <Xinput.h>
#include <algorithm>
#include <unordered_map>
#include <memory>

#include <imgui.h>
#include <utility/Config.hpp>

#include <sdk/Math.hpp>
#include <sdk/UGameEngine.hpp>
#include <sdk/FViewportInfo.hpp>

#include "Framework.hpp"

class IModValue {
public:
    using Ptr = std::unique_ptr<IModValue>;

    virtual ~IModValue() {};
    virtual bool draw(std::string_view name) = 0;
    virtual void draw_value(std::string_view name) = 0;
    virtual void config_load(const utility::Config& cfg, bool set_defaults) = 0;
    virtual void config_save(utility::Config& cfg) = 0;
    virtual void set(const std::string& value) = 0;
    virtual std::string get() const = 0;
    virtual std::string get_config_name() const = 0;
    virtual std::string_view get_config_name_view() const = 0;
};

// Convenience classes for imgui
template <typename T>
class ModValue : public IModValue {
public:
    using Ptr = std::unique_ptr<ModValue<T>>;

    static auto create(std::string_view config_name, T default_value = T{}, bool advanced_option = false) {
        return std::make_unique<ModValue<T>>(config_name, default_value, advanced_option);
    }

    ModValue(std::string_view config_name, T default_value, bool advanced_option = false) 
        : m_config_name{ config_name },
        m_value{ default_value }, 
        m_default_value{ default_value },
        m_advanced_option{ advanced_option }
    {
    }

    virtual ~ModValue() override {};

    virtual void config_load(const utility::Config& cfg, bool set_defaults) override {
        if (set_defaults) {
            m_value = m_default_value;
            return;
        }

        if constexpr (std::is_same_v<T, std::string>) {
            auto v = cfg.get(m_config_name);

            if (v) {
                m_value = *v;
            }
        } else {
            auto v = cfg.get<T>(m_config_name);

            if (v) {
                m_value = *v;
            }
        }
    };

    virtual void config_save(utility::Config& cfg) override {
        if constexpr (std::is_same_v<T, std::string>) {
            cfg.set(m_config_name, m_value);
        } else {
            cfg.set<T>(m_config_name, m_value);
        }
    };

    virtual std::string get() const override {
        if constexpr (std::is_same_v<T, std::string> || std::is_same_v<T, std::string_view>) {
            return m_value;
        } else if constexpr (std::is_same_v<T, bool>) {
            return m_value ? "true" : "false";
        } else {
            return std::to_string(m_value);
        }
    }

    virtual void set(const std::string& value) override {
        if constexpr (std::is_same_v<T, std::string> || std::is_same_v<T, std::string_view>) {
            m_value = value;
            return;
        }

        else if constexpr (std::is_same_v<T, bool>) {
            m_value = value == "true" || value == "1";
            return;
        }

        // Use the correct conversion function based on the type.
        else if constexpr (std::is_integral_v<T>) {
            if constexpr (std::is_unsigned_v<T>) {
                m_value = (T)std::stoul(value);
                return;
            }

            m_value = (T)std::stol(value);
            return;
        } else if constexpr (std::is_floating_point_v<T>) {
            m_value = (T)std::stod(value);
            return;
        }

        static_assert(std::is_same_v<T, void> == false, "Unsupported type for ModValue::set");
    }

    operator T&() {
        return m_value;
    }

    T& value() {
        return m_value;
    }

    T& default_value() {
        return m_default_value;
    }

    std::string get_config_name() const override {
        return m_config_name;
    }

    std::string_view get_config_name_view() const override {
        return m_config_name;
    }

    bool is_advanced_option() const {
        return m_advanced_option;
    }

    bool should_draw_option() const {
        return g_framework->is_advanced_view_enabled() || !this->m_advanced_option;
    }
    

    void context_menu_logic() {
        if (ImGui::BeginPopupContextItem()) {
            reset_to_default_value_logic();
            ImGui::EndPopup();
        }
    }

    void reset_to_default_value_logic() {
        if (ImGui::Button("Reset to default")) {
            m_value = m_default_value;
        }
    }

protected:
    T m_value{};
    const T m_default_value{};
    const std::string m_config_name{ "Default_ModValue" };
    const bool m_advanced_option{false};
};

class ModToggle : public ModValue<bool> {
public:
    using Ptr = std::unique_ptr<ModToggle>;

    ModToggle(std::string_view config_name, bool default_value, bool advanced_option = false) 
        : ModValue<bool>{ config_name, default_value, advanced_option } 
    { 
    }

    static auto create(std::string_view config_name, bool default_value = false, bool advanced_option = false) {
        return std::make_unique<ModToggle>(config_name, default_value, advanced_option);
    }
    
    bool draw(std::string_view name) override {
        if (!should_draw_option()) {
            return false;
        }
        
        ImGui::PushID(this);
        auto ret = ImGui::Checkbox(name.data(), &m_value);
        context_menu_logic();
        ImGui::PopID();

        return ret;
    }

    void draw_value(std::string_view name) override {
        if (!should_draw_option()) {
            return;
        }

        ImGui::Text("%s: %i", name.data(), m_value);
    }

    bool toggle() {
        return m_value = !m_value;
    }
};

class ModFloat : public ModValue<float> {
public:
    using Ptr = std::unique_ptr<ModFloat>;

    ModFloat(std::string_view config_name, float default_value, bool advanced_option = false) 
        : ModValue<float>{ config_name, default_value, advanced_option } { }

    static auto create(std::string_view config_name, float default_value = 0.0f, bool advanced_option = false) {
        return std::make_unique<ModFloat>(config_name, default_value, advanced_option);
    }

    bool draw(std::string_view name) override {
        if (!should_draw_option()) {
            return false;
        }

        ImGui::PushID(this);
        auto ret = ImGui::InputFloat(name.data(), &m_value);
        context_menu_logic();
        ImGui::PopID();

        return ret;
    }

    void draw_value(std::string_view name) override {
        if (!should_draw_option()) {
            return;
        }

        ImGui::Text("%s: %f", name.data(), m_value);
    }
};

class ModSlider : public ModFloat {
public:
    using Ptr = std::unique_ptr<ModSlider>;

    static auto create(std::string_view config_name, float mn = 0.0f, float mx = 1.0f, float default_value = 0.0f, bool advanced_option = false) {
        return std::make_unique<ModSlider>(config_name, mn, mx, default_value, advanced_option);
    }

    ModSlider(std::string_view config_name, float mn = 0.0f, float mx = 1.0f, float default_value = 0.0f, bool advanced_option = false)
        : ModFloat{ config_name, default_value, advanced_option },
        m_range{ mn, mx }
    {
    }

    bool draw(std::string_view name) override {
        if (!should_draw_option()) {
            return false;
        }


        ImGui::PushID(this);
        auto ret = ImGui::SliderFloat(name.data(), &m_value, m_range.x, m_range.y);
        context_menu_logic();
        ImGui::PopID();

        return ret;
    }

    void draw_value(std::string_view name) override {
        if (!should_draw_option()) {
            return;
        }

        ImGui::Text("%s: %f [%f, %f]", name.data(), m_value, m_range.x, m_range.y);
    }

    auto& range() {
        return m_range;
    }

protected:
    Vector2f m_range{ 0.0f, 1.0f };
};

class ModInt32 : public ModValue<int32_t> {
public:
    using Ptr = std::unique_ptr<ModInt32>;

    static auto create(std::string_view config_name, int32_t default_value = 0, bool advanced_option = false) {
        return std::make_unique<ModInt32>(config_name, default_value, advanced_option);
    }

    ModInt32(std::string_view config_name, int32_t default_value = 0, bool advanced_option = false)
        : ModValue{ config_name, default_value, advanced_option }
    {
    }

    bool draw(std::string_view name) override {
        if (!should_draw_option()) {
            return false;
        }

        ImGui::PushID(this);
        auto ret = ImGui::InputInt(name.data(), &m_value);
        context_menu_logic();
        ImGui::PopID();

        return ret;
    }

    void draw_value(std::string_view name) override {
        if (!should_draw_option()) {
            return;
        }

        ImGui::Text("%s: %i", name.data(), m_value);
    }
};

class ModSliderInt32 : public ModInt32 {
public:
    using Ptr = std::unique_ptr<ModSliderInt32>;

    static auto create(std::string_view config_name, int32_t mn = -100, int32_t mx = 100, int32_t default_value = 0, bool advanced_option = false) {
        return std::make_unique<ModSliderInt32>(config_name, mn, mx, default_value, advanced_option);
    }

    ModSliderInt32(std::string_view config_name, int32_t mn = -100, int32_t mx = 100, int32_t default_value = 0, bool advanced_option = false)
        : ModInt32{ config_name, default_value, advanced_option },
        m_int_range{ mn, mx }
    {
    }

    bool draw(std::string_view name) override {
        if (!should_draw_option()) {
            return false;
        }

        ImGui::PushID(this);
        auto ret = ImGui::SliderInt(name.data(), &m_value, m_int_range.min, m_int_range.max);
        context_menu_logic();
        ImGui::PopID();

        return ret;
    }

    void draw_value(std::string_view name) override {
        ImGui::Text("%s: %i [%i, %i]", name.data(), m_value, m_int_range.min, m_int_range.max);
    }

    auto& range() {
        return m_int_range;
    }

protected:
    struct SliderIntRange {
        int min;
        int max;
    }m_int_range;
};

class ModCombo : public ModValue<int32_t> {
public:
    using Ptr = std::unique_ptr<ModCombo>;

    static auto create(std::string_view config_name, std::vector<std::string> options, int32_t default_value = 0, bool advanced_option = false) {
        return std::make_unique<ModCombo>(config_name, options, default_value, advanced_option);
    }

    ModCombo(std::string_view config_name, const std::vector<std::string>& options, int32_t default_value = 0, bool advanced_option = false)
        : ModValue{ config_name, default_value, advanced_option },
        m_options_stdstr{ options }
    {
        for (auto& o : m_options_stdstr) {
            m_options.push_back(o.c_str());
        }
    }

    bool draw(std::string_view name) override {
        if (!should_draw_option()) {
            return false;
        }

        // clamp m_value to valid range
        m_value = std::clamp<int32_t>(m_value, 0, static_cast<int32_t>(m_options.size()) - 1);

        ImGui::PushID(this);
        auto ret = ImGui::Combo(name.data(), &m_value, m_options.data(), static_cast<int32_t>(m_options.size()));
        context_menu_logic();
        ImGui::PopID();

        return ret;
    }

    void draw_value(std::string_view name) override {
        if (!should_draw_option()) {
            return;
        }

        m_value = std::clamp<int32_t>(m_value, 0, static_cast<int32_t>(m_options.size()) - 1);

        ImGui::Text("%s: %s", name.data(), m_options[m_value]);
    }

    void config_load(const utility::Config& cfg, bool set_defaults) override {
        ModValue<int32_t>::config_load(cfg, set_defaults);

        if (m_value >= (int32_t)m_options.size()) {
            if (!m_options.empty()) {
                m_value = (int32_t)m_options.size() - 1;
            } else {
                m_value = 0;
            }
        }

        if (m_value < 0) {
            m_value = 0;
        }
    };

    const auto& options() const {
        return m_options;
    }
    
protected:
    std::vector<const char*> m_options{};
    std::vector<std::string> m_options_stdstr{};
};

class ModKey: public ModInt32 {
public:
    using Ptr = std::unique_ptr<ModKey>;

    static auto create(std::string_view config_name, int32_t default_value = UNBOUND_KEY, bool advanced_option = false) {
        return std::make_unique<ModKey>(config_name, default_value);
    }

    ModKey(std::string_view config_name, int32_t default_value = UNBOUND_KEY, bool advanced_option = false)
        : ModInt32{ config_name, default_value, advanced_option }
    {
    }

    bool draw(std::string_view name) override {
        if (!should_draw_option()) {
            return false;
        }

        if (name.empty()) {
            return false;
        }

        ImGui::PushID(this);
        ImGui::Button(name.data());
        context_menu_logic();

        if (ImGui::IsItemHovered() && ImGui::GetIO().MouseDown[0]) {
            m_waiting_for_new_key = true;
        }

        if (m_waiting_for_new_key) {
            const auto &keys = g_framework->get_keyboard_state();
            for (int32_t k{ 0 }; k < keys.size(); ++k) {
                if (k == VK_LBUTTON || k == VK_RBUTTON) {
                    continue;
                }

                if (keys[k]) {
                    m_value = is_erase_key(k) ? UNBOUND_KEY : k;
                    m_waiting_for_new_key = false;
                    break;
                }
            }

            ImGui::SameLine();
            ImGui::Text("Press any key...");
        }
        else {
            ImGui::SameLine();

            if (m_value >= 0 && m_value <= 255) {
                if (keycodes.contains(m_value)) {
                    ImGui::Text("%s", keycodes[m_value].c_str());
                }
                else {
                    ImGui::Text("%i (Unknown)", m_value);
                }
            }
            else {
                ImGui::Text("Not bound");
            }
        }

        ImGui::PopID();

        return true;
    }

    bool is_key_down() const {
        if (m_value < 0 || m_value > 255) {
            return false;
        }

        if (m_value == VK_LBUTTON || m_value == VK_RBUTTON) {
            return false;
        }

        return g_framework->get_keyboard_state()[(uint8_t)m_value] != 0;
    }

    bool is_key_down_once() {
        auto down = is_key_down();

        if (!m_was_key_down && down) {
            m_was_key_down = true;
            return true;
        }

        if (!down) {
            m_was_key_down = false;
        }

        return false;
    }

    bool is_erase_key(uint8_t k) const {
        switch (k) {
        case VK_ESCAPE:
        case VK_BACK:
            return true;

        default:
            return false;
        }
    }

    static constexpr int32_t UNBOUND_KEY{ -1 };
    static std::unordered_map<int, std::string> keycodes;

protected:
    bool m_was_key_down{ false };
    bool m_waiting_for_new_key{ false };
};

class ModString : public ModValue<std::string> {
public:
    using Ptr = std::unique_ptr<ModString>;

    static auto create(std::string_view config_name, std::string default_value = "", bool advanced_option = false) {
        return std::make_unique<ModString>(config_name, default_value, advanced_option);
    }

    ModString(std::string_view config_name, std::string default_value = "", bool advanced_option = false)
        : ModValue{ config_name, default_value, advanced_option }
    {
    }

    // No use for actually displaying this yet, so leaving them out for now
    bool draw(std::string_view name) override {
        if (!should_draw_option()) {
            return false;
        }

        // TODO

        return false;
    }

    void draw_value(std::string_view name) override {
        if (!should_draw_option()) {
            return;
        }

        ImGui::Text("%s: %s", name.data(), m_value.c_str());
    }

    void config_load(const utility::Config& cfg, bool set_defaults) override {
        if (set_defaults) {
            m_value = m_default_value;
            return;
        }

        auto v = cfg.get(m_config_name);

        if (v) {
            m_value = *v;
        }
    };
};

class ModComponent;

class Mod {
public:
    using ValueList = std::vector<std::reference_wrapper<IModValue>>;

    virtual ~Mod() {};
    virtual std::string_view get_name() const { return "UnknownMod"; };
    virtual bool is_advanced_mod() const { return false; };

    // can be used for ModValues, like Mod_ValueName
    virtual std::string generate_name(std::string_view name) { return std::string{ get_name() } + "_" + name.data(); }

    virtual std::optional<std::string> on_initialize() { return std::nullopt; };
    virtual std::optional<std::string> on_initialize_d3d_thread() { return std::nullopt; };

    virtual std::vector<SidebarEntryInfo> get_sidebar_entries() { return {}; };

    // This gets called after updating stuff like keyboard/mouse input to imgui
    // can be used to override these inputs e.g. with a custom input system
    // like VR controllers
    virtual void on_pre_imgui_frame() {};
    virtual void on_frame() {}; // BeginRendering, can be used for imgui
    virtual void on_present() {}; // actual present frame, CANNOT be used for imgui
    virtual void on_post_frame() {}; // after imgui rendering is done
    virtual void on_post_present() {}; // actually after present gets called
    virtual void on_draw_ui() {};
    virtual void on_draw_sidebar_entry(std::string_view in_entry) {};
    virtual void on_device_reset() {};
    virtual bool on_message(HWND wnd, UINT message, WPARAM w_param, LPARAM l_param) { return true; };
    virtual void on_xinput_get_state(uint32_t* retval, uint32_t user_index, XINPUT_STATE* state) {};
    virtual void on_xinput_set_state(uint32_t* retval, uint32_t user_index, XINPUT_VIBRATION* vibration) {};

    virtual void on_post_render_vr_framework_dx11(ID3D11DeviceContext* context, ID3D11Texture2D* tex, ID3D11RenderTargetView* rtv) {};
    virtual void on_post_render_vr_framework_dx12(ID3D12GraphicsCommandList* command_list, ID3D12Resource* tex, D3D12_CPU_DESCRIPTOR_HANDLE* rtv) {};
    
    virtual void on_config_load(const utility::Config& cfg, bool set_defaults);
    virtual void on_config_save(utility::Config& cfg);

    virtual IModValue* get_value(std::string_view name) const;

    // game specific
    virtual void on_pre_engine_tick(sdk::UGameEngine* engine, float delta) {};
    virtual void on_post_engine_tick(sdk::UGameEngine* engine, float delta) {};
    virtual void on_pre_slate_draw_window(void* renderer, void* command_list, sdk::FViewportInfo* viewport_info) {};
    virtual void on_post_slate_draw_window(void* renderer, void* command_list, sdk::FViewportInfo* viewport_info) {};
    virtual void on_early_calculate_stereo_view_offset(void* stereo_device, const int32_t view_index, Rotator<float>* view_rotation, 
                                                     const float world_to_meters, Vector3f* view_location, bool is_double) {};
    virtual void on_pre_calculate_stereo_view_offset(void* stereo_device, const int32_t view_index, Rotator<float>* view_rotation, 
                                                     const float world_to_meters, Vector3f* view_location, bool is_double) {};
    virtual void on_post_calculate_stereo_view_offset(void* stereo_device, const int32_t view_index, Rotator<float>* view_rotation, 
                                                      const float world_to_meters, Vector3f* view_location, bool is_double) {};
    virtual void on_pre_viewport_client_draw(void* viewport_client, void* viewport, void* canvas) {};
    virtual void on_post_viewport_client_draw(void* viewport_client, void* viewport, void* canvas) {};

protected:
    ValueList m_options{};
    std::vector<ModComponent*> m_components{};
};

class ModComponent : public Mod {
public:
    // todo?
};

inline void Mod::on_config_load(const utility::Config& cfg, bool set_defaults) {
    for (auto& value : m_options) {
        value.get().config_load(cfg, set_defaults);
    }

    for (auto& component : m_components) {
        component->on_config_load(cfg, set_defaults);
    }
}

inline void Mod::on_config_save(utility::Config& cfg) {
    for (const auto& value : m_options) {
        value.get().config_save(cfg);
    }

    for (auto& component : m_components) {
        component->on_config_save(cfg);
    }
}

inline IModValue* Mod::get_value(std::string_view name) const {
    auto it = std::find_if(m_options.begin(), m_options.end(), [&name](const auto& v) {
        return v.get().get_config_name_view() == name;
    });

    if (it == m_options.end()) {
        for (auto& component : m_components) {
            auto value = component->get_value(name);

            if (value != nullptr) {
                return value;
            }
        }

        return nullptr;
    }

    return &it->get();
}

`

---
## ðŸ“ Mods.cpp
**Sti:** $filePath  
**StÃ¸rrelse:** 2517 bytes  
**Sidst Ã¦ndret:** 2025-08-18 19:28:41

### ðŸ”— Includes
`cpp
#include <spdlog/spdlog.h>
`

### ðŸ—ï¸ Classes
`cpp

`

### âš™ï¸ Functions
`cpp
void Mods::reload_config(bool set_defaults)
`

### ðŸ“„ Komplet Indhold
`cpp
#include <spdlog/spdlog.h>

#include "Framework.hpp"

#include "mods/FrameworkConfig.hpp"
#include "mods/VR.hpp"
#include "mods/PluginLoader.hpp"
#include "mods/LuaLoader.hpp"
#include "mods/UObjectHook.hpp"
#include "Mods.hpp"

Mods::Mods() {
    m_mods.emplace_back(FrameworkConfig::get());
    m_mods.emplace_back(VR::get());
    m_mods.emplace_back(UObjectHook::get());

    m_mods.emplace_back(PluginLoader::get());
    m_mods.emplace_back(LuaLoader::get());
}

std::optional<std::string> Mods::on_initialize() const {
    std::scoped_lock _{g_framework->get_hook_monitor_mutex()};

    for (auto& mod : m_mods) {
        spdlog::info("{:s}::on_initialize()", mod->get_name().data());

        if (auto e = mod->on_initialize(); e != std::nullopt) {
            spdlog::info("{:s}::on_initialize() has failed: {:s}", mod->get_name().data(), *e);
            return e;
        }
    }

    return std::nullopt;
}

std::optional<std::string> Mods::on_initialize_d3d_thread() const {
    std::scoped_lock _{g_framework->get_hook_monitor_mutex()};

    // once here to at least setup the values
    reload_config();

    for (auto& mod : m_mods) {
        spdlog::info("{:s}::on_initialize_d3d_thread()", mod->get_name().data());

        if (auto e = mod->on_initialize_d3d_thread(); e != std::nullopt) {
            spdlog::info("{:s}::on_initialize_d3d_thread() has failed: {:s}", mod->get_name().data(), *e);
            return e;
        }
    }

    reload_config();

    return std::nullopt;
}

void Mods::reload_config(bool set_defaults) const {
    utility::Config cfg{ Framework::get_persistent_dir("config.txt").string() };

    for (auto& mod : m_mods) {
        spdlog::info("{:s}::on_config_load()", mod->get_name().data());
        mod->on_config_load(cfg, set_defaults);
    }
}

void Mods::on_pre_imgui_frame() const {
    for (auto& mod : m_mods) {
        mod->on_pre_imgui_frame();
    }
}

void Mods::on_frame() const {
    for (auto& mod : m_mods) {
        mod->on_frame();
    }
}

void Mods::on_present() const {
    for (auto& mod : m_mods) {
        mod->on_present();
    }
}

void Mods::on_post_frame() const {
    for (auto& mod : m_mods) {
        mod->on_post_frame();
    }
}

void Mods::on_draw_ui() const {
    for (auto& mod : m_mods) {
        mod->on_draw_ui();
    }
}

void Mods::on_device_reset() const {
    for (auto& mod : m_mods) {
        mod->on_device_reset();
    }
}

`

---
## ðŸ“ Mods.hpp
**Sti:** $filePath  
**StÃ¸rrelse:** 605 bytes  
**Sidst Ã¦ndret:** 2025-08-18 19:28:41

### ðŸ”— Includes
`cpp
#include "Mod.hpp"
`

### ðŸ—ï¸ Classes
`cpp
class Mods {
`

### âš™ï¸ Functions
`cpp
void reload_config(bool set_defaults = false)
`

### ðŸ“„ Komplet Indhold
`cpp
#pragma once

#include "Mod.hpp"

class Mods {
public:
    Mods();
    virtual ~Mods() {}

    std::optional<std::string> on_initialize() const;
    std::optional<std::string> on_initialize_d3d_thread() const;
    void reload_config(bool set_defaults = false) const;

    void on_pre_imgui_frame() const;
    void on_frame() const;
    void on_present() const;
    void on_post_frame() const;
    void on_draw_ui() const;
    void on_device_reset() const;

    const auto& get_mods() const {
        return m_mods;
    }

private:
    std::vector<std::shared_ptr<Mod>> m_mods;
};
`

---
## ðŸ“ WindowFilter.cpp
**Sti:** $filePath  
**StÃ¸rrelse:** 2506 bytes  
**Sidst Ã¦ndret:** 2025-08-18 19:28:41

### ðŸ”— Includes
`cpp
#include "WindowFilter.hpp"
`

### ðŸ—ï¸ Classes
`cpp

`

### âš™ï¸ Functions
`cpp

`

### ðŸ“„ Komplet Indhold
`cpp
#include "WindowFilter.hpp"

// To prevent usage of statics (TLS breaks the present thread...?)
std::unique_ptr<WindowFilter> g_window_filter{};

WindowFilter& WindowFilter::get() {
    if (g_window_filter == nullptr) {
        g_window_filter = std::make_unique<WindowFilter>();
    }

    return *g_window_filter;
}

WindowFilter::WindowFilter() {
    // We create a job thread because GetWindowTextA can actually deadlock inside
    // the present thread...
    m_job_thread = std::make_unique<std::jthread>([this](std::stop_token s){
        while (!s.stop_requested()) {
            std::this_thread::sleep_for(std::chrono::milliseconds{100});

            m_last_job_tick = std::chrono::steady_clock::now();

            if (m_window_jobs.empty()) {
                return;
            }

            std::scoped_lock _{m_mutex};

            for (const auto hwnd : m_window_jobs) {
                if (is_filtered_nocache(hwnd)) {
                    filter_window(hwnd);
                }
            }

            m_window_jobs.clear();
        }
    });
}

WindowFilter::~WindowFilter() {
    m_job_thread->request_stop();
    m_job_thread->join();
}

bool WindowFilter::is_filtered(HWND hwnd) {
    if (hwnd == nullptr) {
        return true;
    }
    
    std::scoped_lock _{m_mutex};

    if (m_filtered_windows.find(hwnd) != m_filtered_windows.end()) {
        return true;
    }

    // If there is a job for this window, filter it until the job is done
    if (m_window_jobs.find(hwnd) != m_window_jobs.end()) {
        // If the thread is dead for some reason, do not filter it.
        return std::chrono::steady_clock::now() - m_last_job_tick <= std::chrono::seconds{2};
    }

    // if we havent even seen this window yet, add it to the job queue
    // and return true;
    if (m_seen_windows.find(hwnd) == m_seen_windows.end()) {
        m_seen_windows.insert(hwnd);
        m_window_jobs.insert(hwnd);
        return true;
    }

    return false;
}

bool WindowFilter::is_filtered_nocache(HWND hwnd) {
    // get window name
    char window_name[256]{};
    GetWindowTextA(hwnd, window_name, sizeof(window_name));

    const auto sv = std::string_view{window_name};

    if (sv.find("UE4SS") != std::string_view::npos) {
        return true;
    }

    if (sv.find("PimaxXR") != std::string_view::npos) {
        return true;
    }

    // TODO: more problematic windows
    return false;
}
`

---
## ðŸ“ WindowFilter.hpp
**Sti:** $filePath  
**StÃ¸rrelse:** 825 bytes  
**Sidst Ã¦ndret:** 2025-08-18 19:28:41

### ðŸ”— Includes
`cpp
#include <Windows.h>
`

### ðŸ—ï¸ Classes
`cpp
class WindowFilter {
`

### âš™ï¸ Functions
`cpp
void filter_window(HWND hwnd)
`

### ðŸ“„ Komplet Indhold
`cpp
#pragma once

#include <Windows.h>

#include <string_view>
#include <unordered_set>
#include <thread>
#include <vector>
#include <mutex>
#include <chrono>

class WindowFilter {
public:
    static WindowFilter& get();

public:
    WindowFilter();
    virtual ~WindowFilter();

    bool is_filtered(HWND hwnd);

    void filter_window(HWND hwnd) {
        std::scoped_lock _{m_mutex};
        m_filtered_windows.insert(hwnd);
    }

private:
    bool is_filtered_nocache(HWND hwnd);

    std::recursive_mutex m_mutex{};
    std::unordered_set<HWND> m_window_jobs{};
    std::unique_ptr<std::jthread> m_job_thread{};

    std::unordered_set<HWND> m_seen_windows{};
    std::unordered_set<HWND> m_filtered_windows{};
    std::chrono::time_point<std::chrono::steady_clock> m_last_job_tick{};
};
`

---
## ðŸ“ ExceptionHandler.cpp
**Sti:** $filePath  
**StÃ¸rrelse:** 3724 bytes  
**Sidst Ã¦ndret:** 2025-08-18 19:28:41

### ðŸ”— Includes
`cpp
#include <windows.h>
`

### ðŸ—ï¸ Classes
`cpp

`

### âš™ï¸ Functions
`cpp
void framework::setup_exception_handler()
`

### ðŸ“„ Komplet Indhold
`cpp
#include <windows.h>
#include <DbgHelp.h>
#include <ShlObj.h>
#include <filesystem>
#include <spdlog/spdlog.h>

#include <utility/Module.hpp>
#include <utility/Scan.hpp>
#include <utility/Patch.hpp>

#include "Framework.hpp"

#include "ExceptionHandler.hpp"

LONG WINAPI framework::global_exception_handler(struct _EXCEPTION_POINTERS* ei) {
    spdlog::flush_on(spdlog::level::err);

    spdlog::error("Exception occurred: {:x}", ei->ExceptionRecord->ExceptionCode);
    spdlog::error("RIP: {:x}", ei->ContextRecord->Rip);
    spdlog::error("RSP: {:x}", ei->ContextRecord->Rsp);
    spdlog::error("RCX: {:x}", ei->ContextRecord->Rcx);
    spdlog::error("RDX: {:x}", ei->ContextRecord->Rdx);
    spdlog::error("R8: {:x}", ei->ContextRecord->R8);
    spdlog::error("R9: {:x}", ei->ContextRecord->R9);
    spdlog::error("R10: {:x}", ei->ContextRecord->R10);
    spdlog::error("R11: {:x}", ei->ContextRecord->R11);
    spdlog::error("R12: {:x}", ei->ContextRecord->R12);
    spdlog::error("R13: {:x}", ei->ContextRecord->R13);
    spdlog::error("R14: {:x}", ei->ContextRecord->R14);
    spdlog::error("R15: {:x}", ei->ContextRecord->R15);
    spdlog::error("RAX: {:x}", ei->ContextRecord->Rax);
    spdlog::error("RBX: {:x}", ei->ContextRecord->Rbx);
    spdlog::error("RBP: {:x}", ei->ContextRecord->Rbp);
    spdlog::error("RSI: {:x}", ei->ContextRecord->Rsi);
    spdlog::error("RDI: {:x}", ei->ContextRecord->Rdi);
    spdlog::error("EFLAGS: {:x}", ei->ContextRecord->EFlags);
    spdlog::error("CS: {:x}", ei->ContextRecord->SegCs);
    spdlog::error("DS: {:x}", ei->ContextRecord->SegDs);
    spdlog::error("ES: {:x}", ei->ContextRecord->SegEs);
    spdlog::error("FS: {:x}", ei->ContextRecord->SegFs);
    spdlog::error("GS: {:x}", ei->ContextRecord->SegGs);
    spdlog::error("SS: {:x}", ei->ContextRecord->SegSs);

    const auto module_within = utility::get_module_within(ei->ContextRecord->Rip);

    if (module_within) {
        const auto module_path = utility::get_module_path(*module_within);

        if (module_path) {
            spdlog::error("Module: {:x} {}", (uintptr_t)*module_within, *module_path);
        } else {
            spdlog::error("Module: Unknown");
        }
    } else {
        spdlog::error("Module: Unknown");
    }

    auto dbghelp = LoadLibrary("dbghelp.dll");

    if (dbghelp) {
        const auto final_path = Framework::get_persistent_dir("crash.dmp").string();

        spdlog::error("Attempting to write dump to {}", final_path);

        auto f = CreateFile(final_path.c_str(), 
            GENERIC_WRITE, 
            FILE_SHARE_WRITE, 
            nullptr, 
            CREATE_ALWAYS, 
            FILE_ATTRIBUTE_NORMAL, 
            nullptr
        );

        if (!f || f == INVALID_HANDLE_VALUE) {  
            spdlog::error("Exception occurred, but could not create dump file");
            return EXCEPTION_CONTINUE_SEARCH;
        }

        MINIDUMP_EXCEPTION_INFORMATION ei_info{
            GetCurrentThreadId(),
            ei,
            FALSE
        };

        auto minidump_write_dump = (decltype(MiniDumpWriteDump)*)GetProcAddress(dbghelp, "MiniDumpWriteDump");

        minidump_write_dump(GetCurrentProcess(), 
            GetCurrentProcessId(),
            f,
            MINIDUMP_TYPE::MiniDumpNormal, 
            &ei_info, 
            nullptr, 
            nullptr
        );

        CloseHandle(f);
    } else {
        spdlog::error("Exception occurred, but could not load dbghelp.dll");
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

void framework::setup_exception_handler() {
    SetUnhandledExceptionFilter(global_exception_handler);
}

`

---
## ðŸ“ ExceptionHandler.hpp
**Sti:** $filePath  
**StÃ¸rrelse:** 154 bytes  
**Sidst Ã¦ndret:** 2025-08-18 19:28:41

### ðŸ”— Includes
`cpp
#include <windows.h>
`

### ðŸ—ï¸ Classes
`cpp

`

### âš™ï¸ Functions
`cpp
void setup_exception_handler()
`

### ðŸ“„ Komplet Indhold
`cpp
#include <windows.h>

namespace framework {
LONG WINAPI global_exception_handler(struct _EXCEPTION_POINTERS* ei);
void setup_exception_handler();
}

`

---
